# Combined source code for commit: 123
# Generated on: 2025-03-23 17:34:22



# ** File: functions/index.js **
// 1) Import Functions + Admin SDK
const { onDocumentWritten } = require('firebase-functions/v2/firestore');
const { logger } = require('firebase-functions'); // optional for logs
const admin = require('firebase-admin');
// 2) Initialize Admin if not already
admin.initializeApp();
// 3) Access Firestore via admin
const db = admin.firestore();
/**
* Triggers whenever a `delivery_checklist/{docId}` doc is created/updated/deleted.
* We specifically look for changes in the `newPrice` field, and apply them
* to non-delivered orders containing that product (same weekCode).
*/
exports.applyPriceChangeToAllOrders = onDocumentWritten(
{
document: 'delivery_checklist/{docId}',
// optionally you can set `region` / `timeoutSeconds` / `memory`
},
async (event) => {
// If the document was deleted, exit
if (!event.data.after) {
return null;
}
// old data vs. new data
const oldData = event.data.before?.data() || {};
const newData = event.data.after.data() || {};
// Make sure `productId` and `newPrice` exist
if (!newData.productId) {
logger.info('No productId in new data, skipping...');
return null;
}
if (typeof newData.newPrice !== 'number') {
logger.info('No numeric newPrice in new data, skipping...');
return null;
}
// If `newPrice` hasn't changed, do nothing
if (newData.newPrice === oldData.newPrice) {
logger.info('newPrice did not change, skipping...');
return null;
}
// Require a weekCode (so we only update the current week's orders).
const weekCode = newData.weekCode;
if (!weekCode) {
logger.info('No weekCode in new data, skipping...');
return null;
}
const productId = newData.productId;
const newPrice = newData.newPrice;
// 4) Query the "orders" collection for the matching weekCode.
// We'll filter out delivered status in code below.
const ordersSnap = await db
.collection('orders')
.where('weekCode', '==', weekCode)
.get();
if (ordersSnap.empty) {
logger.info(`No orders found for weekCode=${weekCode} to update.`);
return null;
}
// 5) Filter out orders that are explicitly "delivered".
//    If deliveryStatus is missing or anything else, we apply the new price.
const relevantDocs = ordersSnap.docs.filter((docSnap) => {
const data = docSnap.data();
return data.deliveryStatus !== 'delivered'; // keep only non-delivered
});
if (relevantDocs.length === 0) {
logger.info('All orders are delivered or none matching. Nothing to update.');
return null;
}
// 6) Batch-update all relevant (non-delivered) orders
const batch = db.batch();
relevantDocs.forEach((orderDoc) => {
const orderData = orderDoc.data();
if (!Array.isArray(orderData.items) || orderData.items.length === 0) {
return; // no items to update
}
let changed = false;
const updatedItems = orderData.items.map((item) => {
if (item.id === productId) {
changed = true;
return { ...item, price: newPrice };
}
return item;
});
if (changed) {
batch.update(orderDoc.ref, {
items: updatedItems,
updatedAt: admin.firestore.FieldValue.serverTimestamp(),
});
}
});
// If no docs got changed at all, skip
if (batch._ops.length === 0) {
logger.info('No items needed updating in non-delivered orders.');
return null;
}
// 7) Commit the batch
await batch.commit();
logger.info(
`Successfully updated non-delivered orders with new price ${newPrice} for productId ${productId}.`
);
return null;
}
);



# ** File: src/reportWebVitals.js **
const reportWebVitals = onPerfEntry => {
if (onPerfEntry && onPerfEntry instanceof Function) {
import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {
getCLS(onPerfEntry);
getFID(onPerfEntry);
getFCP(onPerfEntry);
getLCP(onPerfEntry);
getTTFB(onPerfEntry);
});
}
};
export default reportWebVitals;



# ** File: src/App.css **
.App {
text-align: center;
}
.App-logo {
height: 40vmin;
pointer-events: none;
}
@media (prefers-reduced-motion: no-preference) {
.App-logo {
animation: App-logo-spin infinite 20s linear;
}
}
.App-header {
background-color: #282c34;
min-height: 100vh;
display: flex;
flex-direction: column;
align-items: center;
justify-content: center;
font-size: calc(10px + 2vmin);
color: white;
}
.App-link {
color: #61dafb;
}
@keyframes App-logo-spin {
from {
transform: rotate(0deg);
}
to {
transform: rotate(360deg);
}
}



# ** File: src/index.js **
// src/index.js (example)
import React from 'react';
import ReactDOM from 'react-dom/client';
import App from './App';
import './index.css';
// 1. Import MUI theme utilities
import { createTheme, ThemeProvider } from '@mui/material/styles';
// 2. Create a custom theme specifying the font
const theme = createTheme({
typography: {
fontFamily: 'Space Grotesk, sans-serif',
},
});
const root = ReactDOM.createRoot(document.getElementById('root'));
root.render(
<React.StrictMode>
{/* 3. Wrap your entire app in ThemeProvider */}
<ThemeProvider theme={theme}>
<App />
</ThemeProvider>
</React.StrictMode>
);



# ** File: src/index.css **
@import url('https://fonts.googleapis.com/css2?family=Space+Grotesk:wght@400;500;700&display=swap');
html, body {
height: 100%;
background-color: #F5F3EB; /* Adjust to match the site */
font-family: 'Space Grotesk', sans-serif !important; /* <— updated font */
color: #2D2A26;
}
.container {
max-width: 1200px;
margin: auto;
padding: 2rem;
}
.table-container {
height: calc(100vh - 150px); /* Adjust based on header height */
overflow-y: auto;
border-radius: 10px;
background: white;
}



# ** File: src/App.test.js **
import { render, screen } from '@testing-library/react';
import App from './App';
test('renders learn react link', () => {
render(<App />);
const linkElement = screen.getByText(/learn react/i);
expect(linkElement).toBeInTheDocument();
});



# ** File: src/setupTests.js **
// jest-dom adds custom jest matchers for asserting on DOM nodes.
// allows you to do things like:
// expect(element).toHaveTextContent(/react/i)
// learn more: https://github.com/testing-library/jest-dom
import '@testing-library/jest-dom';



# ** File: src/firebase.js **
import { initializeApp } from 'firebase/app';
import { getAuth } from 'firebase/auth';
import { getFirestore, serverTimestamp } from 'firebase/firestore';
// ADD this import for Storage:
import { getStorage } from 'firebase/storage';
const firebaseConfig = {
apiKey: "AIzaSyAuaXIWX2K08mapzxi0OT7H4pkfnb1WpW4",
authDomain: "ecorce-dev.firebaseapp.com",
projectId: "ecorce-dev",
storageBucket: "ecorce-dev.firebasestorage.app",
messagingSenderId: "1096630557135",
appId: "1:1096630557135:web:94434d5275a2a64e08daba",
measurementId: "G-6K6XZHY6VZ"
};
const app = initializeApp(firebaseConfig);
const auth = getAuth(app);
const firestore = getFirestore(app);
// Export storage:
const storage = getStorage(app);
export { app, auth, firestore, storage, serverTimestamp };



# ** File: src/App.js **
// src/App.js
import React, { useEffect, useState } from 'react';
import { auth, firestore } from './firebase';
import { doc, getDoc } from 'firebase/firestore';
import { BrowserRouter as Router, Routes, Route, Navigate } from 'react-router-dom';
import Login from './components/Login';
import ProductsPage from './components/ProductsPage';
import OrderHistory from './components/OrderHistory';
import DeliveryDashboard from './components/DeliveryDashboard';
function App() {
const [user, setUser] = useState(null);
const [isDelivery, setIsDelivery] = useState(false);
const [loading, setLoading] = useState(true); // New loading state
useEffect(() => {
const unsub = auth.onAuthStateChanged(async (u) => {
setUser(u);
if (u) {
// Check if user is a delivery person
const userDocRef = doc(firestore, 'users', u.uid);
const snap = await getDoc(userDocRef);
if (snap.exists()) {
const data = snap.data();
if (data.delivery === true) {
console.log('Is delivery');
setIsDelivery(true);
} else {
setIsDelivery(false);
}
} else {
setIsDelivery(false);
}
} else {
setIsDelivery(false);
}
setLoading(false); // Loading complete after auth & fetch check
});
return () => unsub();
}, []);
if (loading) {
// Render a loading indicator or nothing until the state is determined
return <div>Loading...</div>;
}
return (
<Router>
<Routes>
{/* Public or login */}
<Route
path="/login"
element={user ? <Navigate to="/" /> : <Login />}
/>
{/* Normal user path */}
<Route
path="/"
element={user ? <ProductsPage user={user} isDelivery={isDelivery} /> : <Navigate to="/login" />}
/>
<Route
path="/orders"
element={user ? <OrderHistory user={user} /> : <Navigate to="/login" />}
/>
{/* Delivery path (only accessible if user isDelivery) */}
<Route
path="/delivery"
element={
user && isDelivery
? <DeliveryDashboard user={user} />
: <Navigate to="/" />
}
/>
{/* Fallback */}
<Route path="*" element={<Navigate to="/" />} />
</Routes>
</Router>
);
}
export default App;



# ** File: src/utils/formatPrice.js **
export function formatPrice(value) {
return parseFloat(value).toFixed(2);
}



# ** File: src/utils/pdfUtils.js **
// src/utils/pdfUtils.js
import jsPDF from 'jspdf';
import autoTable from 'jspdf-autotable';
// 1) Import your local logo image
import logo from '../logo.png';
/**
* Exports a PDF with items sorted alphabetically by 'name',
* plus a custom header with the site logo.
*/
export function exportAggregatedPDF(aggregatedItemsArray, currentWeek, supplierLabel) {
// Sort items by name
const sortedItems = [...aggregatedItemsArray].sort((a, b) => {
const nameA = (a.name || '').toLowerCase();
const nameB = (b.name || '').toLowerCase();
return nameA.localeCompare(nameB);
});
const doc = new jsPDF();
// 2) Insert the logo at top-left corner
//    x=10, y=10, width=30, height auto (approx)
doc.addImage(logo, 'PNG', 10, 10, 30, 0);
// Optionally, add a horizontal line or some text offset
doc.setLineWidth(0.5);
// For example, draw a line from x=10 to x=200 at y=25
doc.line(10, 25, 200, 25);
// 3) Add main title or text below the logo/line
//    Move startY further down if needed
let startY = 35; // move content down so it doesn't overlap
doc.setFontSize(16);
doc.text(`Aggregated Products - Week ${currentWeek}`, 14, startY);
startY += 10;
doc.setFontSize(12);
if (supplierLabel) {
doc.text(`Supplier: ${supplierLabel}`, 14, startY);
startY += 10;
}
// 4) Prepare columns
const columns = [
{ header: 'ID - Name', dataKey: 'name' },
{ header: 'Qty', dataKey: 'quantity' },
{ header: 'Price', dataKey: 'price' },
{ header: 'Line Total', dataKey: 'total' },
];
// 5) Prepare row data for autoTable
const rows = sortedItems.map((item) => ({
name: `ID: ${item.id} - ${item.name}`,
quantity: item.quantity,
price: `$${parseFloat(item.price).toFixed(2)}`,
total: `$${(item.price * item.quantity).toFixed(2)}`,
}));
// 6) Use autoTable, starting below the header
autoTable(doc, {
startY: startY, // use the updated startY
head: [columns.map((col) => col.header)],
body: rows.map((row) => columns.map((col) => row[col.dataKey])),
styles: { fontSize: 10 },
headStyles: { fillColor: [41, 128, 185] },
margin: { horizontal: 14 },
});
// 7) Save the PDF
doc.save(`aggregated_products_week_${currentWeek}${supplierLabel ? `_${supplierLabel}` : ''}.pdf`);
}



# ** File: src/utils/dateUtils.js **
// src/utils/dateUtils.js
export function getWeekCode(date) {
const target = new Date(date);
const dayNr = (target.getDay() + 6) % 7; // Monday = 0
target.setDate(target.getDate() - dayNr + 3);
const firstThursday = new Date(target.getFullYear(), 0, 4);
const diff = target - firstThursday;
const weekNumber = 1 + Math.round(diff / (7 * 24 * 3600 * 1000));
return `${weekNumber < 10 ? '0' + weekNumber : weekNumber}-${target.getFullYear()}`;
}



# ** File: src/components/AddProductDialog.js **
// src/components/AddProductDialog.js
import React, { useState, useEffect } from 'react';
import { collection, query, where, onSnapshot, addDoc } from 'firebase/firestore';
import { firestore } from '../firebase';
import {
Dialog,
DialogTitle,
DialogContent,
DialogActions,
TextField,
List,
ListItem,
ListItemText,
Button,
Box,
FormControl,
InputLabel,
Select,
MenuItem
} from '@mui/material';
export default function AddProductDialog({ open, onClose, onProductSelect }) {
// mode can be "select" (choose an existing product) or "manual" (add new)
const [mode, setMode] = useState('select');
const [searchTerm, setSearchTerm] = useState('');
const [products, setProducts] = useState([]);
// State for manual product form
const [newProduct, setNewProduct] = useState({
name: '',
code: '',
price: '',
supplier: '' // <--- New field for supplier
});
const [loading, setLoading] = useState(false);
// Fetch available products
useEffect(() => {
const productsRef = collection(firestore, 'products');
// Assuming manually added products are also available
const q = query(productsRef, where('available', '==', true));
const unsubscribe = onSnapshot(q, snapshot => {
const prods = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
// Sort so that manually added ones appear first
prods.sort((a, b) => {
if (a.manuallyAdded && !b.manuallyAdded) return -1;
if (!a.manuallyAdded && b.manuallyAdded) return 1;
return a.name.localeCompare(b.name);
});
setProducts(prods);
});
return () => unsubscribe();
}, []);
// Filter products based on search term (only used in select mode)
const filteredProducts = products.filter(product =>
product.name.toLowerCase().includes(searchTerm.toLowerCase())
);
// Handler for manual product submission
const handleManualSubmit = async (e) => {
e.preventDefault();
setLoading(true);
try {
// Prepare new product data; tag it as manually added
const newProdData = {
...newProduct,
price: parseFloat(newProduct.price) || 0,  // fallback to 0 if empty
available: true,
manuallyAdded: true
};
// Add the product to Firestore
const docRef = await addDoc(collection(firestore, 'products'), newProdData);
const createdProduct = { id: docRef.id, ...newProdData };
// Pass the new product to the parent so it can be added to the order
onProductSelect(createdProduct);
// Reset the manual form and mode
setNewProduct({ name: '', code: '', price: '', supplier: '' });
setMode('select');
} catch (error) {
console.error("Error adding new product", error);
} finally {
setLoading(false);
}
};
return (
<Dialog open={open} onClose={onClose} fullWidth maxWidth="sm">
<DialogTitle>
{mode === 'select' ? 'Ajouter un produit' : 'Ajouter un produit manuellement'}
</DialogTitle>
<DialogContent>
{mode === 'select' ? (
<>
<TextField
label="Rechercher"
variant="outlined"
fullWidth
margin="normal"
value={searchTerm}
onChange={(e) => setSearchTerm(e.target.value)}
/>
<List>
{filteredProducts.map(product => (
<ListItem
button
key={product.id}
onClick={() => onProductSelect(product)}
>
<ListItemText
primary={product.name}
secondary={`Prix: $${parseFloat(product.price).toFixed(2)}`}
/>
</ListItem>
))}
</List>
</>
) : (
// Manual entry form
<form onSubmit={handleManualSubmit}>
<TextField
label="Nom du produit"
variant="outlined"
fullWidth
margin="normal"
value={newProduct.name}
onChange={(e) => setNewProduct({ ...newProduct, name: e.target.value })}
required
/>
{/* Code is now NOT mandatory, so removed 'required' */}
<TextField
label="Code du produit"
variant="outlined"
fullWidth
margin="normal"
value={newProduct.code}
onChange={(e) => setNewProduct({ ...newProduct, code: e.target.value })}
/>
<TextField
label="Prix"
variant="outlined"
fullWidth
margin="normal"
type="number"
value={newProduct.price}
onChange={(e) => setNewProduct({ ...newProduct, price: e.target.value })}
required
/>
{/* New dropdown for selecting a supplier */}
<FormControl fullWidth margin="normal">
<InputLabel>Fournisseur</InputLabel>
<Select
label="Fournisseur"
value={newProduct.supplier}
onChange={(e) => setNewProduct({ ...newProduct, supplier: e.target.value })}
required
>
{/* Example static items; replace with dynamic data if needed */}
<MenuItem value="Big Block">Big Block</MenuItem>
<MenuItem value="canadawide">canadawide</MenuItem>
</Select>
</FormControl>
<Box sx={{ display: 'flex', justifyContent: 'space-between', mt: 2 }}>
<Button onClick={() => setMode('select')} color="primary">
Retour
</Button>
<Button type="submit" variant="contained" color="primary" disabled={loading}>
{loading ? "En cours..." : "Ajouter"}
</Button>
</Box>
</form>
)}
</DialogContent>
{/* Only show these DialogActions in 'select' mode */}
{mode === 'select' && (
<DialogActions>
<Button onClick={() => setMode('manual')} variant="contained" color="primary">
Ajouter un produit manuellement
</Button>
<Button onClick={onClose}>Annuler</Button>
</DialogActions>
)}
</Dialog>
);
}



# ** File: src/components/FilterBar.js **
// src/components/FilterBar.js
import React, { useState } from 'react';
import { useTheme } from '@mui/material/styles';
import useMediaQuery from '@mui/material/useMediaQuery';
import {
Box,
Button,
Dialog,
DialogTitle,
DialogContent,
DialogActions,
TextField,
FormControl,
InputLabel,
Select,
MenuItem,
FormControlLabel,
Checkbox,
Typography,
} from '@mui/material';
/**
* A small dialog for mobile screens: user can pick filters.
*/
function MobileFiltersDialog({
open,
onClose,
searchTerm,
setSearchTerm,
selectedCategory,
setSelectedCategory,
selectedSupplier,
setSelectedSupplier,
bioOnly,
setBioOnly,
distinctCategories,
distinctSuppliers,
}) {
return (
<Dialog open={open} onClose={onClose} fullWidth>
<DialogTitle>Filtrer</DialogTitle>
<DialogContent dividers>
<TextField
label="Rechercher"
variant="outlined"
fullWidth
value={searchTerm}
onChange={(e) => setSearchTerm(e.target.value)}
sx={{ mt: 2 }}
/>
<FormControl sx={{ width: '100%', mt: 2 }}>
<InputLabel>Catégorie</InputLabel>
<Select
value={selectedCategory}
onChange={(e) => setSelectedCategory(e.target.value)}
label="Catégorie"
>
<MenuItem value="">Toutes</MenuItem>
{distinctCategories.map((cat) => (
<MenuItem key={cat} value={cat}>
{cat}
</MenuItem>
))}
</Select>
</FormControl>
<FormControl sx={{ width: '100%', mt: 2 }}>
<InputLabel>Fournisseur</InputLabel>
<Select
value={selectedSupplier}
onChange={(e) => setSelectedSupplier(e.target.value)}
label="Fournisseur"
>
<MenuItem value="">Tous</MenuItem>
{distinctSuppliers.map((sup) => (
<MenuItem key={sup} value={sup}>
{sup}
</MenuItem>
))}
</Select>
</FormControl>
<FormControlLabel
sx={{ mt: 2 }}
control={
<Checkbox
checked={bioOnly}
onChange={(e) => setBioOnly(e.target.checked)}
/>
}
label="Bio seulement"
/>
</DialogContent>
<DialogActions>
<Button onClick={onClose}>Fermer</Button>
</DialogActions>
</Dialog>
);
}
/**
* FilterBar decides:
* - On mobile: show a single "Filtrer" button -> opens MobileFiltersDialog
* - On larger screens: show the filters inline
*/
export default function FilterBar({
searchTerm,
setSearchTerm,
selectedCategory,
setSelectedCategory,
selectedSupplier,
setSelectedSupplier,
bioOnly,
setBioOnly,
distinctCategories,
distinctSuppliers,
}) {
const theme = useTheme();
const isMobile = useMediaQuery(theme.breakpoints.down('sm'));
// State for opening the mobile dialog
const [dialogOpen, setDialogOpen] = useState(false);
if (!isMobile) {
// --- Desktop / Tablet Layout (filters inline) ---
return (
<Box sx={{ display: 'flex', gap: 2, alignItems: 'center', mb: 2, flexWrap: 'wrap' }}>
<TextField
label="Rechercher"
variant="outlined"
value={searchTerm}
onChange={(e) => setSearchTerm(e.target.value)}
sx={{ minWidth: 200 }}
/>
<FormControl sx={{ minWidth: 160 }}>
<InputLabel>Catégorie</InputLabel>
<Select
value={selectedCategory}
onChange={(e) => setSelectedCategory(e.target.value)}
label="Catégorie"
>
<MenuItem value="">Toutes</MenuItem>
{distinctCategories.map((cat) => (
<MenuItem key={cat} value={cat}>
{cat}
</MenuItem>
))}
</Select>
</FormControl>
<FormControl sx={{ minWidth: 160 }}>
<InputLabel>Fournisseur</InputLabel>
<Select
value={selectedSupplier}
onChange={(e) => setSelectedSupplier(e.target.value)}
label="Fournisseur"
>
<MenuItem value="">Tous</MenuItem>
{distinctSuppliers.map((sup) => (
<MenuItem key={sup} value={sup}>
{sup}
</MenuItem>
))}
</Select>
</FormControl>
<FormControlLabel
control={
<Checkbox
checked={bioOnly}
onChange={(e) => setBioOnly(e.target.checked)}
/>
}
label="Bio seulement"
/>
</Box>
);
}
// --- Mobile Layout (dialog) ---
return (
<>
<Button
variant="outlined"
onClick={() => setDialogOpen(true)}
sx={{ mb: 2 }}
>
Filtrer
</Button>
<MobileFiltersDialog
open={dialogOpen}
onClose={() => setDialogOpen(false)}
searchTerm={searchTerm}
setSearchTerm={setSearchTerm}
selectedCategory={selectedCategory}
setSelectedCategory={setSelectedCategory}
selectedSupplier={selectedSupplier}
setSelectedSupplier={setSelectedSupplier}
bioOnly={bioOnly}
setBioOnly={setBioOnly}
distinctCategories={distinctCategories}
distinctSuppliers={distinctSuppliers}
/>
</>
);
}



# ** File: src/components/SignatureOverlay.js **
// src/components/SignatureOverlay.js
import React from 'react';
import { Box, Button, Typography } from '@mui/material';
import SignatureCanvas from 'react-signature-canvas';
export default function SignatureOverlay({
open,
sigPadRef,
onClear,
onSave,
onCancel
}) {
if (!open) return null;
return (
<Box
sx={{
// Make sure this is above MUI dialogs, tables, etc.
position: 'fixed',
top: 0, left: 0, right: 0, bottom: 0,
zIndex: 2000,               // <--- NEW: ensure this is on top
backgroundColor: 'rgba(0,0,0,0.5)',
display: 'flex',
justifyContent: 'center',
alignItems: 'center'
}}
>
<Box sx={{ backgroundColor: '#fff', p: 2, borderRadius: 2 }}>
<Typography variant="h6" gutterBottom>
Signature
</Typography>
<SignatureCanvas
ref={sigPadRef}
penColor="black"
// Set backgroundColor to solid white if you do not want to see anything behind
backgroundColor="#fff"  // <--- NEW: opaque background
canvasProps={{ width: 400, height: 200, className: 'sigCanvas' }}
/>
<Box sx={{ mt: 2, display: 'flex', gap: 2 }}>
<Button variant="outlined" onClick={onClear}>
Clear
</Button>
<Button variant="contained" onClick={onSave}>
Save Signature
</Button>
<Button variant="text" onClick={onCancel}>
Cancel
</Button>
</Box>
</Box>
</Box>
);
}



# ** File: src/components/OrderHistory.js **
// src/components/OrderHistory.js
import React, { useState, useEffect } from 'react';
import { collection, query, where, orderBy, onSnapshot } from 'firebase/firestore';
import { firestore } from '../firebase';
import { Link as RouterLink } from 'react-router-dom';
import {
Container,
Typography,
Link,
Paper,
Box,
Chip
} from '@mui/material';
function OrderHistory({ user }) {
const [orders, setOrders] = useState([]);
useEffect(() => {
const ordersRef = collection(firestore, 'orders');
const q = query(
ordersRef,
where('userId', '==', user.uid),
orderBy('createdAt', 'desc')
);
const unsubscribe = onSnapshot(q, snapshot => {
const ordersData = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
setOrders(ordersData);
});
return () => unsubscribe();
}, [user.uid]);
// Helper: Choose chip color based on order status
const getStatusColor = (status) => {
if (status === 'delivered') return 'success';
if (status === 'being delivered') return 'warning';
return 'default';
};
return (
<Container sx={{ py: 4 }}>
<Typography variant="h4" gutterBottom>
Order History
</Typography>
<Link component={RouterLink} to="/">
Back to Products
</Link>
{orders.length === 0 ? (
<Typography sx={{ mt: 2 }}>No orders found.</Typography>
) : (
orders.map(order => {
// 1) Calculate total cost for each order
const totalCost = (order.items || []).reduce(
(acc, item) => acc + (item.price * item.quantity),
0
);
return (
<Paper key={order.id} sx={{ mb: 2, p: 2 }}>
<Typography variant="subtitle1" sx={{ fontWeight: 'bold' }}>
Order ID: {order.id}
</Typography>
<Typography variant="body2">
<strong>Date:</strong>{' '}
{order.createdAt ? order.createdAt.toDate().toLocaleString() : 'N/A'}
</Typography>
{/* Status Chip */}
{order.deliveryStatus && (
<Box sx={{ my: 1 }}>
<Chip
label={order.deliveryStatus}
color={getStatusColor(order.deliveryStatus)}
/>
</Box>
)}
{/* If delivered, show delivery date */}
{order.deliveryStatus === 'delivered' && (
<Typography variant="body2">
<strong>Delivery Date:</strong>{' '}
{order.deliveredAt ? order.deliveredAt.toDate().toLocaleString() : 'N/A'}
</Typography>
)}
{/* Items table */}
<Box sx={{ mt: 1 }}>
<Typography variant="subtitle2" sx={{ mb: 1 }}>
Items:
</Typography>
{/* Table header */}
<Box
sx={{
display: 'flex',
borderBottom: '1px solid #ccc',
fontWeight: 'bold',
pb: 1,
mb: 1
}}
>
<Box sx={{ flex: 1 }}>ID</Box>
<Box sx={{ flex: 2 }}>Name</Box>
<Box sx={{ width: 80, textAlign: 'right' }}>Quantity</Box>
<Box sx={{ width: 80, textAlign: 'right' }}>Price</Box>
</Box>
{/* Render each item (sorted alphabetically by name) */}
{[...(order.items || [])]
.sort((a, b) => a.name.localeCompare(b.name))
.map(item => (
<Box key={item.id} sx={{ mb: 1 }}>
<Box
sx={{
display: 'flex',
alignItems: 'center',
py: 0.5,
borderBottom: '1px dashed #eee'
}}
>
<Box sx={{ flex: 1 }}>{item.id}</Box>
<Box sx={{ flex: 2 }}>{item.name}</Box>
<Box sx={{ width: 80, textAlign: 'right' }}>{item.quantity}</Box>
<Box sx={{ width: 80, textAlign: 'right' }}>
${parseFloat(item.price).toFixed(2)}
</Box>
</Box>
{item.comment && (
<Typography
variant="body2"
sx={{ ml: 2, color: 'grey.600', pt: 0.5 }}
>
Comment: {item.comment}
</Typography>
)}
</Box>
))}
</Box>
{/* Optionally, show signature if available */}
{order.signature && (
<Box sx={{ mt: 1 }}>
<Typography variant="body2"><strong>Signature:</strong></Typography>
<Box
component="img"
src={order.signature}
alt="Signature"
sx={{ maxWidth: 200, border: '1px solid #ccc', p: 0.5, borderRadius: 1 }}
/>
</Box>
)}
{/* 2) Show total cost for this order at the bottom */}
<Typography
variant="body2"
sx={{ textAlign: 'right', mt: 2, fontWeight: 'bold' }}
>
Total: ${totalCost.toFixed(2)}
</Typography>
</Paper>
);
})
)}
</Container>
);
}
export default OrderHistory;



# ** File: src/components/ProductRow.js **
// ProductRow.js
import React, { useState } from 'react';
import { TableRow, TableCell, TextField, Button } from '@mui/material';
import { formatPrice } from '../utils/formatPrice';
function ProductRow({ product, addToBasket, style, columnWidths }) {
const [quantity, setQuantity] = useState(1);
if (!product) {
console.log('[ProductRow] No product found for this row. Possibly out of range?');
return null;
}
const handleAdd = () => {
console.log(`[ProductRow] handleAdd: productId=${product.id}, quantity=${quantity}`);
addToBasket(product, parseInt(quantity, 10));
setQuantity(1);
};
return (
<TableRow style={style}>
<TableCell sx={{ width: columnWidths.name }}>{product.name}</TableCell>
<TableCell sx={{ width: columnWidths.category }}>{product.category}</TableCell>
<TableCell sx={{ width: columnWidths.bio }}>{product.bio ? "Yes" : "No"}</TableCell>
<TableCell sx={{ width: columnWidths.price }}>${formatPrice(product.price)}</TableCell>
<TableCell sx={{ width: columnWidths.quantity }}>
<TextField
type="number"
value={quantity}
onChange={e => setQuantity(e.target.value)}
inputProps={{ min: 1 }}
size="small"
sx={{ width: '60px' }}
/>
</TableCell>
<TableCell sx={{ width: columnWidths.add }}>
<Button variant="contained" onClick={handleAdd}>
Add
</Button>
</TableCell>
</TableRow>
);
}
export default ProductRow;



# ** File: src/components/AggregatedTable.js **
// src/components/AggregatedTable.js
import React from 'react';
import { Box, Paper, Typography, Button, FormControlLabel, Checkbox, TextField } from '@mui/material';
import { exportAggregatedPDF } from '../utils/pdfUtils';
export default function AggregatedTable({
aggregatedBySupplier,
supplierInvoiceUrl,
handleInvoiceFileChangeAndUpload,
toggleCollected,
updateChecklistField,
checklist,
handleOpenReplaceDialog,
currentWeek,
}) {
if (Object.keys(aggregatedBySupplier).length === 0) {
return <Typography>No aggregated products.</Typography>;
}
return (
<>
{Object.keys(aggregatedBySupplier)
.sort()
.map((supplier) => {
const itemsObj = aggregatedBySupplier[supplier];
const itemsArray = Object.values(itemsObj).sort((a, b) => a.name.localeCompare(b.name));
const totalCost = itemsArray.reduce((acc, item) => acc + item.quantity * item.price, 0);
const handleExportPDF = () => {
exportAggregatedPDF(itemsArray, currentWeek, supplier);
};
return (
<Paper key={supplier} sx={{ mb: 2, p: 2 }}>
<Typography variant="h6" gutterBottom>
Supplier: {supplier}
</Typography>
<Button variant="contained" onClick={handleExportPDF} sx={{ mb: 2 }}>
Export PDF
</Button>
<Box
sx={{
display: 'grid',
gridTemplateColumns: {
xs: '1fr 1fr',
sm: '1fr 2fr 0.7fr 0.7fr 1fr 1fr 1fr 1fr',
},
gap: 1,
mb: 1,
fontWeight: 'bold',
borderBottom: '1px solid #ccc',
pb: 1,
width: '100%',
}}
>
<Typography>ID</Typography>
<Typography>Name</Typography>
<Typography sx={{ display: { xs: 'none', sm: 'block' } }}>Qty</Typography>
<Typography sx={{ display: { xs: 'none', sm: 'block' } }}>Coll.</Typography>
<Typography sx={{ textAlign: 'center', display: { xs: 'none', sm: 'block' } }}>
Collected
</Typography>
<Typography sx={{ textAlign: 'center', display: { xs: 'none', sm: 'block' } }}>
New Price
</Typography>
<Typography sx={{ textAlign: 'right', display: { xs: 'none', sm: 'block' } }}>
Orig
</Typography>
<Typography sx={{ textAlign: 'right', display: { xs: 'none', sm: 'block' } }}>
Action
</Typography>
</Box>
{itemsArray.map((item) => {
const quantityChanged =
checklist[item.id]?.collectedQuantity &&
checklist[item.id].collectedQuantity !== item.quantity;
const priceChanged =
checklist[item.id]?.newPrice &&
parseFloat(checklist[item.id].newPrice) !== parseFloat(item.price);
return (
<Box
key={item.id}
sx={{
display: 'grid',
gridTemplateColumns: {
xs: '1fr 1fr',
sm: '1fr 2fr 0.7fr 0.7fr 1fr 1fr 1fr 1fr',
},
alignItems: 'center',
gap: 1,
mb: 1,
width: '100%',
p: 0.5,
}}
>
<Typography>{item.id}</Typography>
<Typography>{item.name}</Typography>
<Typography sx={{ textAlign: 'right', display: { xs: 'none', sm: 'block' } }}>
{item.quantity}
</Typography>
<FormControlLabel
control={
<Checkbox
checked={checklist[item.id]?.collected || false}
onChange={() => toggleCollected(item.id)}
/>
}
label=""
sx={{ mr: 0, display: { xs: 'none', sm: 'inline-flex' } }}
/>
<TextField
label="Collected"
type="number"
size="small"
value={
checklist[item.id]?.collectedQuantity !== undefined && checklist[item.id].collectedQuantity !== null
? checklist[item.id].collectedQuantity
: ''
}
onChange={(e) => {
const newValue = e.target.value === '' ? null : parseInt(e.target.value, 10);
updateChecklistField(item.id, 'collectedQuantity', newValue);
}}
inputProps={{
min: 0,
style: { textAlign: 'right' },
inputMode: 'numeric',
pattern: '[0-9]*',
}}
sx={{
width: '100%',
maxWidth: { xs: '90px', sm: '100%' },
bgcolor: quantityChanged ? '#e0f2fe' : 'transparent',
}}
/>
<TextField
label="New Price"
type="number"
size="small"
value={
checklist[item.id]?.newPrice !== undefined && checklist[item.id].newPrice !== null
? checklist[item.id].newPrice
: ''
}
onChange={(e) => {
const newValue = e.target.value === '' ? null : parseFloat(e.target.value);
updateChecklistField(item.id, 'newPrice', newValue);
}}
inputProps={{
min: 0,
style: { textAlign: 'right' },
inputMode: 'decimal',
pattern: '[0-9]*',
}}
sx={{
width: '100%',
maxWidth: { xs: '90px', sm: '100%' },
bgcolor: priceChanged ? '#e0f2fe' : 'transparent',
}}
/>
<Typography sx={{ textAlign: 'right', display: { xs: 'none', sm: 'block' } }}>
${parseFloat(item.price).toFixed(2)}
</Typography>
<Button
variant="outlined"
size="small"
onClick={() => handleOpenReplaceDialog(item.id)}
sx={{ display: { xs: 'none', sm: 'inline-flex' } }}
>
Replace
</Button>
</Box>
);
})}
<Box sx={{ mt: 2, textAlign: 'right', fontWeight: 'bold' }}>
Total: ${totalCost.toFixed(2)}
</Box>
</Paper>
);
})}
</>
);
}



# ** File: src/components/Login.js **
import React, { useState, useEffect } from 'react';
import { isSignInWithEmailLink, signInWithEmailLink, sendSignInLinkToEmail } from 'firebase/auth';
import { auth } from '../firebase';
import { useLocation } from 'react-router-dom';
import { Container, Typography, TextField, Button, Box, Alert } from '@mui/material';
function Login() {
const [email, setEmail] = useState('');
const [message, setMessage] = useState('');
const location = useLocation();
useEffect(() => {
if (isSignInWithEmailLink(auth, window.location.href)) {
let storedEmail = window.localStorage.getItem('emailForSignIn');
if (!storedEmail) {
storedEmail = window.prompt('Please provide your email for confirmation');
}
signInWithEmailLink(auth, storedEmail, window.location.href)
.then(() => {
window.localStorage.removeItem('emailForSignIn');
})
.catch(error => {
console.error(error);
});
}
}, [location]);
const handleSubmit = async (e) => {
e.preventDefault();
const actionCodeSettings = {
url: window.location.href,
handleCodeInApp: true,
};
try {
await sendSignInLinkToEmail(auth, email, actionCodeSettings);
window.localStorage.setItem('emailForSignIn', email);
setMessage('Login link sent to your email!');
} catch (error) {
console.error(error);
setMessage('Error sending email link');
}
};
return (
<Container maxWidth="sm">
<Box sx={{ mt: 8, p: 4, boxShadow: 3, borderRadius: 2 }}>
<Typography variant="h4" component="h1" gutterBottom>
Login
</Typography>
<form onSubmit={handleSubmit}>
<TextField
fullWidth
label="Email"
variant="outlined"
margin="normal"
type="email"
value={email}
onChange={e => setEmail(e.target.value)}
required
/>
<Button variant="contained" color="primary" type="submit" fullWidth>
Send Login Link
</Button>
</form>
{message && <Alert severity="info" sx={{ mt: 2 }}>{message}</Alert>}
</Box>
</Container>
);
}
export default Login;



# ** File: src/components/NoTag.js **
// NoTag.js
import React from 'react';
const NoTag = React.forwardRef(({ children }, ref) => <>{children}</>);
export default NoTag;



# ** File: src/components/ResponsiveProductsView.js **
// src/components/ResponsiveProductsView.js
import React from 'react';
import { useTheme } from '@mui/material/styles';
import useMediaQuery from '@mui/material/useMediaQuery';
import { List, ListItem, ListItemText, Box, Typography, Button } from '@mui/material';
// Import your existing VirtualizedProductsTable:
import VirtualizedProductsTable from './VirtualizedProductsTable';
/**
* A simple card-like list for mobile screens.
* You can customize how many fields to display,
* e.g., category, supplier, etc.
*/
function MobileProductsList({ products, addToBasket }) {
return (
<List>
{products.map((product) => (
<ListItem
key={product.id}
sx={{
display: 'flex',
flexDirection: 'column',
alignItems: 'flex-start',
borderBottom: '1px solid #eee'
}}
>
<Typography variant="subtitle1" sx={{ fontWeight: 'bold' }}>
{product.name}
</Typography>
{/* Example: Show Price and maybe Category */}
<Typography variant="body2" sx={{ mt: 0.5 }}>
Price: ${product.price?.toFixed(2)}
</Typography>
{product.category && (
<Typography variant="body2" sx={{ color: 'grey.600' }}>
Category: {product.category}
</Typography>
)}
{/* "Add to Basket" button */}
<Box sx={{ mt: 1 }}>
<Button
variant="contained"
onClick={() => addToBasket(product, 1)}
>
Ajouter
</Button>
</Box>
</ListItem>
))}
</List>
);
}
/**
* A wrapper that detects if we're on a small screen:
* - If yes, render the mobile list
* - If no, render the VirtualizedProductsTable
*/
export default function ResponsiveProductsView({ products, addToBasket }) {
const theme = useTheme();
const isMobile = useMediaQuery(theme.breakpoints.down('sm'));
if (isMobile) {
// Card/list layout for mobile
return <MobileProductsList products={products} addToBasket={addToBasket} />;
} else {
// Original table for larger screens
return <VirtualizedProductsTable products={products} addToBasket={addToBasket} />;
}
}



# ** File: src/components/DeliveredOrderCard.js **
// src/components/DeliveredOrderCard.js
import React, { useState, useEffect } from 'react';
import { Paper, Typography, Box, Button } from '@mui/material';
import { collection, query, where, getDocs } from 'firebase/firestore';
import { firestore } from '../firebase';
import jsPDF from 'jspdf';
import autoTable from 'jspdf-autotable';
// <-- NEW: import your local logo
import logo from '../logo.png';
export default function DeliveredOrderCard({ order }) {
// Only fetching company info and address now; email comes from order.email
const [address, setAddress] = useState(null);
const [companyName, setCompanyName] = useState('');
useEffect(() => {
const fetchPartnerInfo = async () => {
try {
const partnersRef = collection(firestore, 'res_partner');
const qPartners = query(partnersRef, where('email', '==', order.email));
const querySnapshot = await getDocs(qPartners);
if (!querySnapshot.empty) {
const partnerData = querySnapshot.docs[0].data();
setAddress(partnerData.contact_address_complete || '');
setCompanyName(partnerData.company_name || '');
}
} catch (error) {
console.error('Error fetching address/company info', error);
}
};
fetchPartnerInfo();
}, [order.email]);
// 1) Compute total cost
const totalCost = (order.items || []).reduce(
(acc, item) => acc + item.price * item.quantity,
0
);
const printBill = () => {
const doc = new jsPDF();
// 2) Insert the logo at top-left corner
//    x=10, y=10, width=30, height auto (approx)
doc.addImage(logo, 'PNG', 10, 10, 30, 0);
// Optionally, add a horizontal line across the page, same as aggregator
doc.setLineWidth(0.5);
doc.line(10, 25, 200, 25);
// 3) Add main title or text, after the line
let startY = 35; // move content down
doc.setFontSize(16);
doc.text('Delivery Bill', 14, startY);
startY += 10;
// Additional info (order ID, date, etc.)
doc.setFontSize(12);
doc.text(`Order ID: ${order.id}`, 14, startY);
startY += 8;
const deliveredOn = order.deliveredAt
? order.deliveredAt.toDate().toLocaleString()
: 'N/A';
doc.text(`Delivered on: ${deliveredOn}`, 14, startY);
startY += 10;
if (companyName) {
doc.text(`Company: ${companyName}`, 14, startY);
startY += 8;
}
doc.text(`Email: ${order.email}`, 14, startY);
startY += 8;
if (address) {
doc.text(`Address: ${address}`, 14, startY);
startY += 10;
}
// PDF table with four columns: ID, Name, Quantity, and Price
const tableColumns = ['ID', 'Name', 'Quantity', 'Price'];
const tableRows = (order.items || []).map(item => [
item.id,
item.name,
item.quantity.toString(),
`$${parseFloat(item.price).toFixed(2)}`
]);
autoTable(doc, {
startY,
head: [tableColumns],
body: tableRows,
styles: { fontSize: 10 },
headStyles: { fillColor: [41, 128, 185] },
columnStyles: {
2: { halign: 'right' },
3: { halign: 'right' }
}
});
// If there's a signature, place it below the table
let finalY = doc.lastAutoTable.finalY || startY;
if (order.signature) {
doc.text('Signature:', 14, finalY + 15);
doc.addImage(order.signature, 'PNG', 14, finalY + 20, 60, 30);
finalY += 45; // enough space for the signature
} else {
finalY = finalY + 10; // small gap
}
// Optionally, show total cost below the table
doc.setFontSize(12);
doc.setFont('', 'bold');
doc.text(`Total: $${totalCost.toFixed(2)}`, 14, finalY + 10);
// 4) Save the PDF
doc.save(`delivery_bill_order_${order.id}.pdf`);
};
return (
<Paper sx={{ mb: 2, p: 2, backgroundColor: '#f7f7f7' }}>
<Typography variant="subtitle1" sx={{ fontWeight: 'bold' }}>
Order ID: {order.id}
</Typography>
{/* Display company info */}
{companyName && (
<Typography variant="body2" sx={{ mb: 1 }}>
Company: {companyName}
</Typography>
)}
<Typography variant="body2" sx={{ mb: 1 }}>
Email: {order.email}
</Typography>
{address && (
<Typography variant="body2" sx={{ mb: 1 }}>
Address: {address}
</Typography>
)}
<Typography variant="body2">
Delivered on:{' '}
{order.deliveredAt ? order.deliveredAt.toDate().toLocaleString() : 'N/A'}
</Typography>
{/* Web Interface: Items in columns */}
{(order.items && order.items.length > 0) && (
<Box sx={{ mt: 2 }}>
{/* Header Row */}
<Box sx={{ display: 'flex', borderBottom: '1px solid #ccc', pb: 1, mb: 1 }}>
<Box sx={{ flex: 1, fontWeight: 'bold' }}>ID</Box>
<Box sx={{ flex: 3, fontWeight: 'bold' }}>Name</Box>
<Box sx={{ flex: 1, fontWeight: 'bold', textAlign: 'right' }}>Quantity</Box>
<Box sx={{ flex: 1, fontWeight: 'bold', textAlign: 'right' }}>Price</Box>
</Box>
{/* Data Rows */}
{order.items.map(item => (
<Box key={item.id} sx={{ display: 'flex', borderBottom: '1px dashed #ccc', pb: 1, mb: 1 }}>
<Box sx={{ flex: 1 }}>{item.id}</Box>
<Box sx={{ flex: 3 }}>{item.name}</Box>
<Box sx={{ flex: 1, textAlign: 'right' }}>{item.quantity}</Box>
<Box sx={{ flex: 1, textAlign: 'right' }}>
${parseFloat(item.price).toFixed(2)}
</Box>
</Box>
))}
</Box>
)}
{/* Show total cost in the UI as well */}
<Typography
variant="body2"
sx={{ textAlign: 'right', mt: 2, fontWeight: 'bold' }}
>
Total: ${totalCost.toFixed(2)}
</Typography>
{/* If signature, show it in the UI */}
{order.signature && (
<Box sx={{ mt: 2 }}>
<Typography variant="body2"><strong>Signature:</strong></Typography>
<Box
component="img"
src={order.signature}
alt="Signature"
sx={{ maxWidth: 200, border: '1px solid #ccc', p: 0.5, borderRadius: 1 }}
/>
</Box>
)}
<Button variant="contained" onClick={printBill} sx={{ mt: 2 }}>
Print Delivery Bill
</Button>
</Paper>
);
}



# ** File: src/components/DeliveryDashboard.js **
// src/components/DeliveryDashboard.js
import React, { useState, useEffect, useRef } from 'react';
import {
collection,
query,
where,
onSnapshot,
updateDoc,
setDoc,
doc,
getDoc,
getDocs,
serverTimestamp
} from 'firebase/firestore';
import { firestore, storage } from '../firebase';
import {
ref,
uploadBytesResumable,
getDownloadURL
} from 'firebase/storage';
import {
Box,
Typography,
Button,
Dialog,
DialogTitle,
DialogContent,
DialogActions,
TextField,
Checkbox,
FormControlLabel
} from '@mui/material';
import { useDeliveryAggregation } from '../hooks/useDeliveryAggregation';
import AggregatedTable from './AggregatedTable';
import SignatureOverlay from './SignatureOverlay';
import DeliveredOrderCard from './DeliveredOrderCard';
import AddProductDialog from './AddProductDialog';
import OrderCard from './OrderCard';
import { getWeekCode } from '../utils/dateUtils';
/**
* Dialog pour sélectionner les commandes qui contiennent l’ancien produit.
* L’utilisateur peut cocher celles à remplacer.
*/
function ReplaceOrdersSelectionDialog({
open,
ordersForReplacement,
selectedOrders,
setSelectedOrders,
oldProductIdToReplace, // Pour afficher la quantité de l’ancien produit
onClose,
onNext
}) {
if (!open) return null;
const handleToggleOrder = (orderId) => {
if (selectedOrders.includes(orderId)) {
setSelectedOrders(selectedOrders.filter(id => id !== orderId));
} else {
setSelectedOrders([...selectedOrders, orderId]);
}
};
return (
<Dialog open={open} onClose={onClose} fullWidth maxWidth="sm">
<DialogTitle>Sélectionner les commandes à remplacer</DialogTitle>
<DialogContent dividers>
<Typography variant="body2" sx={{ mb: 2 }}>
Les commandes suivantes contiennent l'ancien produit. Sélectionnez celles où vous souhaitez le remplacer.
</Typography>
{ordersForReplacement.length === 0 ? (
<Typography>Aucune commande ne contient l'ancien produit.</Typography>
) : (
ordersForReplacement.map((order) => {
// Trouver l’item qui correspond à l’ancien produit
const matchingItem = order.items.find(
(item) => item.id === oldProductIdToReplace
);
const quantity = matchingItem ? matchingItem.quantity : 0;
return (
<Box key={order.id} sx={{ mb: 1 }}>
<FormControlLabel
control={
<Checkbox
checked={selectedOrders.includes(order.id)}
onChange={() => handleToggleOrder(order.id)}
/>
}
label={`ID de commande : ${order.id} | ${order.email || ''} | Qté : ${quantity}`}
/>
</Box>
);
})
)}
</DialogContent>
<DialogActions>
<Button onClick={onClose} color="secondary">
Annuler
</Button>
<Button
onClick={onNext}
variant="contained"
color="primary"
disabled={ordersForReplacement.length === 0}
>
Suivant
</Button>
</DialogActions>
</Dialog>
);
}
export default function DeliveryDashboard({ user }) {
// Récupération via le hook d’agrégation
const { orders, aggregatedBySupplier, supplierInvoiceUrl, currentWeek } = useDeliveryAggregation();
// --------------------------------------------------
//  Signature pad
// --------------------------------------------------
const [sigPadOpen, setSigPadOpen] = useState(null);
const sigPadRef = useRef(null);
// --------------------------------------------------
//  Factures fournisseurs (invoices)
// --------------------------------------------------
const [supplierInvoiceUrlState, setSupplierInvoiceUrlState] = useState(supplierInvoiceUrl);
// --------------------------------------------------
//  Checklist pour “collected”, “collectedQuantity”, “newPrice”
// --------------------------------------------------
const [checklist, setChecklist] = useState({});
// Charger le checklist depuis Firestore (comme dans l'ancienne version)
useEffect(() => {
const wc = getWeekCode(new Date());
const checklistRef = collection(firestore, 'delivery_checklist');
const qC = query(checklistRef, where('weekCode', '==', wc));
const unsub = onSnapshot(qC, (snapshot) => {
const data = {};
snapshot.docs.forEach((docSnap) => {
const d = docSnap.data();
data[d.productId] = { id: docSnap.id, ...d };
});
setChecklist(data);
});
return () => unsub();
}, []);
// Activer / désactiver “collected” pour un produit
const toggleCollected = async (productId) => {
const wc = getWeekCode(new Date());
if (checklist[productId]) {
// Inverse la valeur “collected”
const newStatus = !checklist[productId].collected;
try {
await updateDoc(doc(firestore, 'delivery_checklist', checklist[productId].id), {
collected: newStatus,
updatedAt: serverTimestamp()
});
} catch (error) {
console.error("Erreur lors de la mise à jour du checklist", error);
}
} else {
// Crée un nouveau document checklist
try {
const newDocRef = doc(collection(firestore, 'delivery_checklist'));
await setDoc(newDocRef, {
weekCode: wc,
productId,
collected: true,
collectedQuantity: 0,
newPrice: 0,
createdAt: serverTimestamp(),
updatedAt: serverTimestamp()
});
} catch (error) {
console.error("Erreur lors de la création du document checklist", error);
}
}
};
// Mettre à jour un champ du checklist (collectedQuantity ou newPrice)
const updateChecklistField = async (productId, field, value) => {
const wc = getWeekCode(new Date());
const numericValue = value !== null ? value : null;
if (checklist[productId]) {
// Update existing doc
try {
await updateDoc(doc(firestore, 'delivery_checklist', checklist[productId].id), {
[field]: numericValue,
updatedAt: serverTimestamp()
});
} catch (error) {
console.error("Erreur lors de la mise à jour d'un champ du checklist", error);
}
} else {
// Create new doc if nonexistent
try {
const newDocRef = doc(collection(firestore, 'delivery_checklist'));
await setDoc(newDocRef, {
weekCode: wc,
productId,
collected: false,
collectedQuantity: field === 'collectedQuantity' ? numericValue : null,
newPrice: field === 'newPrice' ? numericValue : null,
createdAt: serverTimestamp(),
updatedAt: serverTimestamp()
});
} catch (error) {
console.error("Erreur lors de la création du document checklist", error);
}
}
};
// --------------------------------------------------
//  "Add Product" dialog
// --------------------------------------------------
const [addProductDialogOpen, setAddProductDialogOpen] = useState(false);
const [selectedOrderForProductAddition, setSelectedOrderForProductAddition] = useState(null);
// --------------------------------------------------
//  "Replace Product" feature
// --------------------------------------------------
const [replaceDialogOpen, setReplaceDialogOpen] = useState(false);
const [oldProductIdToReplace, setOldProductIdToReplace] = useState(null);
// Step 2: user picks new product
const [pendingNewProduct, setPendingNewProduct] = useState(null);
// Orders selection dialog
const [replaceOrdersSelectionOpen, setReplaceOrdersSelectionOpen] = useState(false);
const [ordersForReplacement, setOrdersForReplacement] = useState([]);
const [selectedOrdersForReplacement, setSelectedOrdersForReplacement] = useState([]);
// Final confirm
const [replaceConfirmOpen, setReplaceConfirmOpen] = useState(false);
const [ordersAffectedCount, setOrdersAffectedCount] = useState(0);
// --------------------------------------------------
//  Gestion des commandes actives / livrées
// --------------------------------------------------
const activeOrders = orders.filter(o => o.deliveryStatus !== 'delivered');
const deliveredOrders = orders.filter(o => o.deliveryStatus === 'delivered');
const sortedActiveOrders = [...activeOrders].sort((a, b) => (a.email || '').localeCompare(b.email || ''));
const sortedDeliveredOrders = [...deliveredOrders].sort((a, b) => (a.email || '').localeCompare(b.email || ''));
// --------------------------------------------------
//  Invoices
// --------------------------------------------------
const handleInvoiceFileChangeAndUpload = async (supplier, file) => {
try {
const invoiceRef = ref(storage, `invoices/${currentWeek}/${supplier}/${file.name}`);
const uploadTask = uploadBytesResumable(invoiceRef, file);
uploadTask.on(
'state_changed',
() => {},
(error) => {
console.error("Erreur lors du téléversement de la facture :", error);
alert("Erreur lors du téléversement de la facture");
},
async () => {
const downloadURL = await getDownloadURL(uploadTask.snapshot.ref);
const docId = `${currentWeek}_${supplier}`;
await setDoc(
doc(firestore, 'delivery_invoices', docId),
{
weekCode: currentWeek,
invoiceUrl: downloadURL,
updatedAt: serverTimestamp()
},
{ merge: true }
);
setSupplierInvoiceUrlState((prev) => ({
...prev,
[supplier]: downloadURL
}));
}
);
} catch (err) {
console.error("Erreur lors du téléversement de la facture", err);
}
};
// --------------------------------------------------
//  Order item modifications
// --------------------------------------------------
// Mettre à jour la quantité d’un item dans une commande
const handleQuantityChange = async (orderId, itemId, newQty) => {
const order = orders.find(o => o.id === orderId);
if (!order) return;
const updatedItems = (order.items || []).map(item => {
if (item.id === itemId) {
return { ...item, quantity: parseInt(newQty, 10) || 0 };
}
return item;
});
try {
await updateDoc(doc(firestore, 'orders', orderId), {
items: updatedItems,
updatedAt: serverTimestamp()
});
} catch (err) {
console.error("Erreur lors de la mise à jour de la quantité", err);
}
};
// Marquer une commande comme livrée
const markAsDelivered = async (orderId) => {
try {
await updateDoc(doc(firestore, 'orders', orderId), {
deliveryStatus: 'delivered',
deliveredAt: serverTimestamp()
});
} catch (err) {
console.error("Erreur lors du marquage de la commande comme livrée", err);
}
};
// --------------------------------------------------
//  Signature
// --------------------------------------------------
const openSignaturePad = (orderId) => {
setSigPadOpen(orderId);
};
const clearSignature = () => {
sigPadRef.current?.clear();
};
const saveSignature = async () => {
if (!sigPadRef.current) return;
const orderId = sigPadOpen;
const signatureDataUrl = sigPadRef.current.toDataURL('image/png');
try {
await updateDoc(doc(firestore, 'orders', orderId), {
signature: signatureDataUrl,
updatedAt: serverTimestamp()
});
setSigPadOpen(null);
} catch (err) {
console.error("Erreur lors de l'enregistrement de la signature", err);
}
};
// --------------------------------------------------
//  "Add Product" to Order
// --------------------------------------------------
const handleOpenAddProduct = (orderId) => {
setSelectedOrderForProductAddition(orderId);
setAddProductDialogOpen(true);
};
const handleCloseAddProduct = () => {
setAddProductDialogOpen(false);
setSelectedOrderForProductAddition(null);
};
const handleAddProductToOrder = async (orderId, product) => {
const order = orders.find(o => o.id === orderId);
if (!order) return;
let newItems = [];
let found = false;
if (order.items) {
newItems = order.items.map(item => {
if (item.id === product.id) {
found = true;
return { ...item, quantity: item.quantity + 1 };
}
return item;
});
} else {
newItems = [];
}
if (!found) {
newItems.push({ ...product, quantity: 1 });
}
try {
await updateDoc(doc(firestore, 'orders', orderId), {
items: newItems,
updatedAt: serverTimestamp()
});
console.log(`Produit « ${product.name} » ajouté à la commande ${orderId}`);
} catch (error) {
console.error("Erreur lors de l'ajout du produit à la commande", error);
}
};
// --------------------------------------------------
//  "Replace Product" Feature
// --------------------------------------------------
// Étape 1 : Choisir le produit à remplacer
const handleOpenReplaceDialog = (oldProductId) => {
setOldProductIdToReplace(oldProductId);
setReplaceDialogOpen(true);
};
const handleCloseReplaceDialog = () => {
setReplaceDialogOpen(false);
setOldProductIdToReplace(null);
};
// Étape 2 : Choisir le nouveau produit dans AddProductDialog
const handleStartReplaceConfirmation = (newProduct) => {
if (!oldProductIdToReplace) return;
// Trouver les commandes contenant l'ancien produit
const relevantOrders = orders.filter(order =>
(order.items || []).some(item => item.id === oldProductIdToReplace)
);
setOrdersForReplacement(relevantOrders);
// Sélectionner toutes par défaut
setSelectedOrdersForReplacement(relevantOrders.map(o => o.id));
setPendingNewProduct(newProduct);
// Fermer la boîte de dialogue de sélection
setReplaceDialogOpen(false);
// Ouvrir la boîte de dialogue “ReplaceOrdersSelection”
setReplaceOrdersSelectionOpen(true);
};
// Étape 3 : l’utilisateur coche les commandes à remplacer
const handleCloseReplaceOrdersSelection = () => {
setReplaceOrdersSelectionOpen(false);
setPendingNewProduct(null);
setOldProductIdToReplace(null);
};
const handleNextFromReplaceOrdersSelection = () => {
// Calculer combien de commandes seront affectées
setOrdersAffectedCount(selectedOrdersForReplacement.length);
setReplaceOrdersSelectionOpen(false);
setReplaceConfirmOpen(true);
};
// Étape 4 : confirmation finale
const handleConfirmReplace = () => {
if (!pendingNewProduct || !oldProductIdToReplace) return;
handleReplaceProductInAllOrders(pendingNewProduct);
setReplaceConfirmOpen(false);
setPendingNewProduct(null);
};
const handleCancelReplace = () => {
setReplaceConfirmOpen(false);
setPendingNewProduct(null);
setOldProductIdToReplace(null);
};
// Étape 5 : faire le remplacement dans toutes les commandes sélectionnées
const handleReplaceProductInAllOrders = async (newProduct) => {
let updatedCount = 0;
// Ne remplacer que dans les commandes sélectionnées
const newOrdersState = orders.map(order => {
if (!selectedOrdersForReplacement.includes(order.id)) {
return order;
}
const items = order.items || [];
let changed = false;
const updatedItems = items.map(item => {
if (item.id === oldProductIdToReplace) {
changed = true;
return {
...item,
id: newProduct.id,
name: newProduct.name,
price: newProduct.price,
supplier: newProduct.supplier || 'Unknown'
};
}
return item;
});
if (changed) {
updatedCount++;
// Mettre à jour Firestore
updateDoc(doc(firestore, 'orders', order.id), {
items: updatedItems,
updatedAt: serverTimestamp()
}).catch(err => {
console.error(`Erreur lors de la mise à jour de la commande ${order.id}`, err);
});
return { ...order, items: updatedItems };
}
return order;
});
console.log(
`Produit ${oldProductIdToReplace} remplacé par ${newProduct.id} dans ${updatedCount} commande(s) sélectionnée(s).`
);
// Réinitialiser
setOldProductIdToReplace(null);
setOrdersForReplacement([]);
setSelectedOrdersForReplacement([]);
};
// --------------------------------------------------
//  Render
// --------------------------------------------------
return (
<Box sx={{ p: 2 }}>
<Typography variant="h4" gutterBottom>
Tableau de bord des livraisons
</Typography>
<Typography variant="body1" gutterBottom>
Commandes pour la semaine : {currentWeek}
</Typography>
{/* Agrégation des articles */}
<Box
sx={{
mt: 4,
border: '1px solid #ccc',
p: 2,
borderRadius: 1,
width: '100%'
}}
>
<Box sx={{ display: 'flex', alignItems: 'center', mb: 2 }}>
<Typography variant="h5" sx={{ ml: 2 }}>
Bons de commandes aux fournisseurs - Semaine {currentWeek}
</Typography>
</Box>
<AggregatedTable
aggregatedBySupplier={aggregatedBySupplier}
supplierInvoiceUrl={supplierInvoiceUrlState}
currentWeek={currentWeek}
checklist={checklist}
toggleCollected={toggleCollected}
updateChecklistField={updateChecklistField}
handleInvoiceFileChangeAndUpload={handleInvoiceFileChangeAndUpload}
handleOpenReplaceDialog={handleOpenReplaceDialog}
/>
</Box>
<Typography variant="h5" sx={{ mt: 4, mb: 2 }}>
Livraisons
</Typography>
{/* Commandes actives */}
{sortedActiveOrders.length === 0 ? (
<Typography>Aucune commande active pour cette semaine.</Typography>
) : (
sortedActiveOrders.map(order => (
<OrderCard
key={order.id}
order={order}
onMarkDelivered={markAsDelivered}
onOpenSignaturePad={openSignaturePad}
onQuantityChange={handleQuantityChange}
onAddProduct={handleOpenAddProduct}
/>
))
)}
{/* Commandes livrées */}
{sortedDeliveredOrders.length > 0 && (
<>
<Typography variant="h5" sx={{ mt: 4, mb: 2 }}>
Commandes livrées
</Typography>
{sortedDeliveredOrders.map(order => (
<DeliveredOrderCard key={order.id} order={order} />
))}
</>
)}
{/* Overlay de signature */}
<SignatureOverlay
open={!!sigPadOpen}
sigPadRef={sigPadRef}
onClear={clearSignature}
onSave={saveSignature}
onCancel={() => setSigPadOpen(null)}
/>
{/* "Add Product" Dialog existant */}
<AddProductDialog
open={addProductDialogOpen}
onClose={handleCloseAddProduct}
onProductSelect={(product) => {
handleAddProductToOrder(selectedOrderForProductAddition, product);
handleCloseAddProduct();
}}
/>
{/* Étape 1 : choisir l’ancien produit à remplacer */}
<AddProductDialog
open={replaceDialogOpen}
onClose={handleCloseReplaceDialog}
onProductSelect={(product) => {
handleStartReplaceConfirmation(product);
}}
/>
{/* Étape 2 : Sélection des commandes où remplacer */}
<ReplaceOrdersSelectionDialog
open={replaceOrdersSelectionOpen}
ordersForReplacement={ordersForReplacement}
selectedOrders={selectedOrdersForReplacement}
setSelectedOrders={setSelectedOrdersForReplacement}
oldProductIdToReplace={oldProductIdToReplace}
onClose={handleCloseReplaceOrdersSelection}
onNext={handleNextFromReplaceOrdersSelection}
/>
{/* Étape 3 : confirmation finale */}
<Dialog open={replaceConfirmOpen} onClose={handleCancelReplace}>
<DialogTitle>Confirmer le remplacement du produit</DialogTitle>
<DialogContent>
<Typography>
Vous êtes sur le point de remplacer le produit <strong>{oldProductIdToReplace}</strong> dans{' '}
<strong>{ordersAffectedCount}</strong> commande(s) sélectionnée(s). Continuer ?
</Typography>
</DialogContent>
<DialogActions>
<Button onClick={handleCancelReplace} color="secondary">
Annuler
</Button>
<Button onClick={handleConfirmReplace} variant="contained" color="primary">
Confirmer
</Button>
</DialogActions>
</Dialog>
</Box>
);
}



# ** File: src/components/CustomTbody.js **
// CustomTbody.js
import React from 'react';
const CustomTbody = React.forwardRef((props, ref) => (
<tbody ref={ref} {...props} />
));
export default CustomTbody;



# ** File: src/components/VirtualizedProductsTable.js **
// src/components/VirtualizedProductsTable.js
import React from 'react';
import { FixedSizeList as List } from 'react-window';
import AutoSizer from 'react-virtualized-auto-sizer';
// Définitions de colonnes de base
// Ajout d'une nouvelle colonne pour "Fournisseur" avec une largeur de base de 120
const columns = [
{ label: 'Bio', baseWidth: 40 },
{ label: 'Produit', baseWidth: 300 },
{ label: 'Catégorie', baseWidth: 150 },
{ label: 'Fournisseur', baseWidth: 120 },
{ label: 'Prix', baseWidth: 80 },
{ label: 'Quantité', baseWidth: 60 },
{ label: 'Ajouter', baseWidth: 60 },
];
const ROW_HEIGHT = 50;
/**
* Rendu d'une ligne de données (sans en-tête).
*/
const RowRendererWithoutHeader = ({ index, style, data }) => {
const { products, addToBasket, scaledColumns } = data;
const product = products[index];
if (!product) return null;
const formattedPrice = parseFloat(product.price).toFixed(2);
return (
<div style={{ ...style, display: 'flex', borderBottom: '1px solid #eee' }}>
{/* Colonne 1 : Bio */}
<div
style={{
width: scaledColumns[0].scaledWidth,
padding: '8px',
boxSizing: 'border-box',
}}
>
{product.bio ? '🌿' : ''}
</div>
{/* Colonne 2 : Nom du produit */}
<div
style={{
width: scaledColumns[1].scaledWidth,
padding: '8px',
boxSizing: 'border-box',
}}
>
{product.name}
</div>
{/* Colonne 3 : Catégorie */}
<div
style={{
width: scaledColumns[2].scaledWidth,
padding: '8px',
boxSizing: 'border-box',
}}
>
{product.category}
</div>
{/* Colonne 4 : Fournisseur */}
<div
style={{
width: scaledColumns[3].scaledWidth,
padding: '8px',
boxSizing: 'border-box',
}}
>
{product.supplier || ''}
</div>
{/* Colonne 5 : Prix (aligné à droite) */}
<div
style={{
width: scaledColumns[4].scaledWidth,
padding: '8px',
boxSizing: 'border-box',
textAlign: 'right',
}}
>
${formattedPrice}
</div>
{/* Colonne 6 : Quantité (fixée à "1" dans cet exemple minimal) */}
<div
style={{
width: scaledColumns[5].scaledWidth,
padding: '8px',
boxSizing: 'border-box',
}}
>
1
</div>
{/* Colonne 7 : Bouton Ajouter */}
<div
style={{
width: scaledColumns[6].scaledWidth,
padding: '8px',
boxSizing: 'border-box',
}}
>
<button onClick={() => addToBasket(product, 1)}>Ajouter</button>
</div>
</div>
);
};
function VirtualizedProductsTable({ products, addToBasket }) {
// Largeur totale de toutes les colonnes combinées, avant le redimensionnement
const totalBaseWidth = columns.reduce((sum, col) => sum + col.baseWidth, 0);
return (
<div style={{ height: '80vh', width: '100%' }}>
<AutoSizer>
{({ width, height }) => {
const ratio = totalBaseWidth > 0 ? width / totalBaseWidth : 1;
const scaledColumns = columns.map((col) => ({
label: col.label,
scaledWidth: col.baseWidth * ratio,
}));
// Réserver de l'espace pour la ligne d'en-tête
const headerHeight = ROW_HEIGHT;
const listHeight = height - headerHeight;
return (
<>
{/* En-tête fixe */}
<div
style={{
width: `${width}px`,
display: 'flex',
backgroundColor: '#F5F3EB',
fontWeight: 'bold',
height: headerHeight,
}}
>
{scaledColumns.map((col) => (
<div
key={col.label}
style={{
width: col.scaledWidth,
padding: '8px',
boxSizing: 'border-box',
borderRight: '1px solid #ddd',
}}
>
{col.label}
</div>
))}
</div>
{/* Liste déroulante des lignes */}
<List
height={listHeight}
width={width}
itemCount={products.length}
itemSize={ROW_HEIGHT}
itemData={{ products, addToBasket, scaledColumns }}
>
{RowRendererWithoutHeader}
</List>
</>
);
}}
</AutoSizer>
</div>
);
}
export default VirtualizedProductsTable;



# ** File: src/components/OrderCard.js **
// src/components/OrderCard.js
import React, { useState, useEffect } from 'react';
import { collection, query, where, getDocs } from 'firebase/firestore';
import { firestore } from '../firebase';
import {
Paper,
Typography,
Box,
TextField,
Button
} from '@mui/material';
export default function OrderCard({
order,
onMarkDelivered,
onOpenSignaturePad,
onQuantityChange,
onAddProduct
}) {
const [address, setAddress] = useState(null);
const [companyName, setCompanyName] = useState('');
useEffect(() => {
const fetchPartnerInfo = async () => {
try {
const partnersRef = collection(firestore, 'res_partner');
const qPartners = query(partnersRef, where('email', '==', order.email));
const querySnapshot = await getDocs(qPartners);
if (!querySnapshot.empty) {
const partnerData = querySnapshot.docs[0].data();
setAddress(partnerData.contact_address_complete || '');
setCompanyName(partnerData.company_name || '');
}
} catch (error) {
console.error('Error fetching partner info', error);
}
};
fetchPartnerInfo();
}, [order.email]);
// 1) Compute total
const totalCost = (order.items || []).reduce(
(acc, item) => acc + item.price * item.quantity,
0
);
return (
<Paper sx={{ mb: 2, p: 2 }}>
<Typography variant="subtitle1" sx={{ fontWeight: 'bold' }}>
Order ID: {order.id}
</Typography>
{companyName && (
<Typography variant="body2" sx={{ mb: 1 }}>
Company: {companyName}
</Typography>
)}
<Typography variant="body2" sx={{ mb: 1 }}>
Email: {order.email}
</Typography>
{address && (
<Typography variant="body2" sx={{ mb: 1 }}>
Address: {address}
</Typography>
)}
<Typography variant="body2">
Delivery Status: {order.deliveryStatus || 'N/A'}
</Typography>
<Box sx={{ mt: 2 }}>
{(order.items || []).map((item) => (
<Box key={item.id} sx={{ mb: 1 }}>
<Box sx={{ display: 'flex', alignItems: 'center', gap: 2, flexWrap: 'wrap' }}>
{/* Item name */}
<Typography sx={{ flex: 1 }}>{item.name}</Typography>
{/* Supplier */}
<Typography sx={{ flex: 1 }}>
{item.supplier || 'N/A'}
</Typography>
{/* Price (not editable, just displayed) */}
<Typography sx={{ width: '80px', textAlign: 'right' }}>
${parseFloat(item.price).toFixed(2)}
</Typography>
{/* Quantity field: numeric-friendly for mobile */}
<TextField
type="number"
size="small"
value={item.quantity}
onChange={(e) => onQuantityChange(order.id, item.id, e.target.value)}
sx={{
width: { xs: '50px', sm: '60px' },
textAlign: 'right',
}}
inputProps={{
style: { textAlign: 'right' },
min: 0,
inputMode: 'numeric',
pattern: '[0-9]*'
}}
/>
</Box>
{/* Optional comment */}
{item.comment && (
<Typography variant="body2" sx={{ ml: 2, color: 'grey.600' }}>
Comment: {item.comment}
</Typography>
)}
</Box>
))}
</Box>
{/* 2) Show total cost at bottom */}
<Typography
variant="body2"
sx={{ textAlign: 'right', mt: 2, fontWeight: 'bold' }}
>
Total: ${totalCost.toFixed(2)}
</Typography>
<Box sx={{ mt: 2, display: 'flex', gap: 2, alignItems: 'center', flexWrap: 'wrap' }}>
<Button
variant="contained"
onClick={() => onMarkDelivered(order.id)}
disabled={!order.signature}
>
Mark Delivered
</Button>
<Button variant="contained" onClick={() => onAddProduct(order.id)}>
Ajouter un produit
</Button>
{/* If there's a signature, show it; otherwise show the capture button */}
{order.signature ? (
<Box
sx={{
border: '1px solid #ccc',
p: 1,
maxWidth: 200,
maxHeight: 100,
overflow: 'hidden'
}}
>
<img
src={order.signature}
alt="Signature"
style={{ width: '100%', height: 'auto' }}
/>
</Box>
) : (
<Button variant="outlined" onClick={() => onOpenSignaturePad(order.id)}>
Capture Signature
</Button>
)}
</Box>
</Paper>
);
}



# ** File: src/components/Basket.js **
import React, { useState, useEffect } from 'react';
import { Box, Button, Typography, IconButton, TextField, Collapse } from '@mui/material';
import RemoveCircleOutlineIcon from '@mui/icons-material/RemoveCircleOutline';
import ExpandLessIcon from '@mui/icons-material/ExpandLess';
import ExpandMoreIcon from '@mui/icons-material/ExpandMore';
function Basket({ basket, updateBasketItem, updateBasketItemComment, removeBasketItem, saveOrder, isOrderAllowed }) {
const [expanded, setExpanded] = useState(false);
// État local pour suivre l'affichage du champ de commentaire pour chaque article.
const [commentOpen, setCommentOpen] = useState({});
// Lorsque le panier change, s'assurer que les articles avec un commentaire existant soient ouverts par défaut.
useEffect(() => {
setCommentOpen(prev => {
const newState = { ...prev };
basket.forEach(item => {
if (item.comment && item.comment.trim() !== '' && !newState[item.id]) {
newState[item.id] = true;
}
});
return newState;
});
}, [basket]);
const toggleExpand = () => setExpanded(!expanded);
const toggleComment = (id) => {
setCommentOpen(prev => ({ ...prev, [id]: !prev[id] }));
};
const totalCost = basket
.reduce((acc, item) => acc + item.price * item.quantity, 0)
.toFixed(2);
return (
<Box
sx={{
position: 'fixed',
bottom: 0,
left: 0,
right: 0,
backgroundColor: 'background.paper',
borderTop: '1px solid',
borderColor: 'grey.300',
p: 2,
boxShadow: 3,
}}
>
<Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>
<Button onClick={toggleExpand} endIcon={expanded ? <ExpandLessIcon /> : <ExpandMoreIcon />}>
{expanded ? 'Masquer le panier' : 'Afficher le panier'}
</Button>
<Typography variant="body1">
{basket.length} articles | Total : ${totalCost}
</Typography>
</Box>
<Collapse in={expanded}>
<Box sx={{ maxHeight: '50vh', overflowY: 'auto', mt: 2 }}>
{basket.length === 0 ? (
<Typography>Aucun article dans le panier</Typography>
) : (
<>
{[...basket]
.sort((a, b) => a.name.localeCompare(b.name))
.map((item) => {
const lineTotal = (item.price * item.quantity).toFixed(2);
return (
<Box key={item.id} sx={{ display: 'flex', flexDirection: 'column', mb: 1, gap: 1 }}>
<Box
sx={{
display: 'flex',
alignItems: 'center',
gap: 2,
flexWrap: 'wrap',
}}
>
<Typography sx={{ flex: 2 }}>
{item.name} - ${parseFloat(item.price).toFixed(2)}
</Typography>
<Typography sx={{ width: '100px', textAlign: 'right' }}>
${lineTotal}
</Typography>
<TextField
type="number"
value={item.quantity}
onChange={(e) => updateBasketItem(item.id, parseInt(e.target.value, 10))}
inputProps={{ min: 1 }}
size="small"
sx={{ width: '60px' }}
/>
<IconButton onClick={() => removeBasketItem(item.id)}>
<RemoveCircleOutlineIcon />
</IconButton>
<Button variant="text" onClick={() => toggleComment(item.id)}>
{commentOpen[item.id] ? 'Masquer le commentaire' : 'Ajouter un commentaire'}
</Button>
</Box>
{commentOpen[item.id] && (
<TextField
label="Commentaire"
variant="outlined"
fullWidth
value={item.comment || ''}
onChange={(e) => updateBasketItemComment(item.id, e.target.value)}
/>
)}
</Box>
);
})}
</>
)}
</Box>
{basket.length > 0 && (
<>
{!isOrderAllowed && (
<Typography variant="caption" color="error" sx={{ display: 'block', mt: 1 }}>
Les commandes ne peuvent être passées que du lundi au mercredi.
</Typography>
)}
</>
)}
</Collapse>
</Box>
);
}
export default Basket;



# ** File: src/components/ProductsPage.js **
// src/components/ProductsPage.js
import React, { useState, useEffect, useRef } from 'react';
import {
collection,
onSnapshot,
addDoc,
updateDoc,
doc,
getDocs,
query,
where,
serverTimestamp,
} from 'firebase/firestore';
import { firestore } from '../firebase';
import { Link } from 'react-router-dom';
import {
Container,
Typography,
Button,
Box
} from '@mui/material';
import Logo from '../logo.svg';
import { signOut } from 'firebase/auth';
import { auth } from '../firebase';
// Import our FilterBar and ResponsiveProductsView:
import FilterBar from './FilterBar';
import ResponsiveProductsView from './ResponsiveProductsView';
import Basket from './Basket';
import { getWeekCode } from '../utils/dateUtils';
function ProductsPage({ user, isDelivery }) {
// --- State for products, basket, user address, etc.
const [products, setProducts] = useState([]);
const [basket, setBasket] = useState([]);
const [userAddress, setUserAddress] = useState('');
const [activeOrderId, setActiveOrderId] = useState(null);
// --- Filter states
const [searchTerm, setSearchTerm] = useState('');
const [selectedCategory, setSelectedCategory] = useState('');
const [selectedSupplier, setSelectedSupplier] = useState('');
const [bioOnly, setBioOnly] = useState(false);
// For auto-saving
const lastRemoteBasketRef = useRef([]);
// For restricting orders to certain days
const today = new Date();
const allowedDays = [1, 2, 3]; // Monday=1, Tuesday=2, Wednesday=3
// or set by environment
const bypassOrderRestrictions = process.env.REACT_APP_BYPASS_ORDER_RESTRICTION === 'true';
const isOrderAllowed = bypassOrderRestrictions || allowedDays.includes(today.getDay());
// Current week code
const currentWeek = getWeekCode(today);
// ------------------------------------------------------------------
//  1) Retrieve user's address from "res_partner"
// ------------------------------------------------------------------
useEffect(() => {
if (user && user.email) {
const fetchAddress = async () => {
try {
const partnersRef = collection(firestore, 'res_partner');
const qPartner = query(partnersRef, where('email', '==', user.email));
const querySnapshot = await getDocs(qPartner);
if (!querySnapshot.empty) {
const partnerData = querySnapshot.docs[0].data();
setUserAddress(partnerData.contact_address_complete || '');
}
} catch (error) {
console.error("Error retrieving address from res_partner:", error);
}
};
fetchAddress();
}
}, [user]);
// ------------------------------------------------------------------
//  2) Retrieve all products (available == true)
// ------------------------------------------------------------------
useEffect(() => {
const productsRef = collection(firestore, 'products');
const q = query(productsRef, where('available', '==', true));
const unsubscribe = onSnapshot(q, (snapshot) => {
const prods = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
setProducts(prods);
});
return () => unsubscribe();
}, []);
// ------------------------------------------------------------------
//  3) Load an "open" order for the user (status == 'open')
// ------------------------------------------------------------------
useEffect(() => {
const ordersRef = collection(firestore, 'orders');
const qOrders = query(
ordersRef,
where('userId', '==', user.uid),
where('status', '==', 'open')
);
const unsubscribe = onSnapshot(qOrders, (snapshot) => {
if (!snapshot.empty) {
// pick the most recently updated open order
const openOrders = snapshot.docs.sort((a, b) => {
const aTime = a.data().updatedAt ? a.data().updatedAt.seconds : 0;
const bTime = b.data().updatedAt ? b.data().updatedAt.seconds : 0;
return bTime - aTime;
});
const activeOrder = openOrders[0];
const data = activeOrder.data();
setActiveOrderId(activeOrder.id);
const remoteItems = data.items || [];
// If remote items differ from local basket, sync them
if (JSON.stringify(remoteItems) !== JSON.stringify(basket)) {
setBasket(remoteItems);
}
lastRemoteBasketRef.current = remoteItems;
} else {
// no open orders, so no basket
setActiveOrderId(null);
setBasket([]);
lastRemoteBasketRef.current = [];
}
});
return () => unsubscribe();
}, [user.uid]);
// ------------------------------------------------------------------
//  Basket modifications
// ------------------------------------------------------------------
const addToBasket = (product, quantity) => {
setBasket(prev => {
const existing = prev.find(item => item.id === product.id);
if (existing) {
return prev.map(item =>
item.id === product.id
? { ...item, quantity: item.quantity + quantity }
: item
);
} else {
return [...prev, { ...product, quantity }];
}
});
};
const updateBasketItem = (id, newQuantity) => {
setBasket(prev =>
prev.map(item => (item.id === id ? { ...item, quantity: newQuantity } : item))
);
};
const updateBasketItemComment = (id, comment) => {
setBasket(prev =>
prev.map(item => (item.id === id ? { ...item, comment } : item))
);
};
const removeBasketItem = (id) => {
setBasket(prev => prev.filter(item => item.id !== id));
};
// ------------------------------------------------------------------
//  Manual order saving
// ------------------------------------------------------------------
const saveOrder = async () => {
if (basket.length === 0) {
alert("Le panier est vide !");
return;
}
if (!isOrderAllowed) {
alert("Les commandes ne peuvent être passées que du lundi au mercredi.");
return;
}
const orderData = {
userId: user.uid,
email: user.email,
items: basket,
weekCode: getWeekCode(new Date()),
status: "open",
updatedAt: serverTimestamp(),
createdAt: serverTimestamp(),
};
try {
if (activeOrderId) {
await updateDoc(doc(firestore, 'orders', activeOrderId), orderData);
alert('Commande mise à jour !');
} else {
const docRef = await addDoc(collection(firestore, 'orders'), orderData);
setActiveOrderId(docRef.id);
alert('Commande créée et enregistrée !');
}
} catch (error) {
console.error('Error saving order:', error);
alert('Erreur lors de l\'enregistrement de la commande');
}
};
// ------------------------------------------------------------------
//  Auto-save effect
// ------------------------------------------------------------------
useEffect(() => {
const timeoutId = setTimeout(() => {
if (!activeOrderId && basket.length > 0) {
// Create new order when there is no active order and basket is non-empty
const orderData = {
userId: user.uid,
email: user.email,
items: basket,
weekCode: getWeekCode(new Date()),
status: "open",
updatedAt: serverTimestamp(),
createdAt: serverTimestamp(),
};
addDoc(collection(firestore, 'orders'), orderData)
.then(docRef => {
setActiveOrderId(docRef.id);
lastRemoteBasketRef.current = basket;
})
.catch(error => {
console.error('Error auto-creating order', error);
});
} else if (activeOrderId) {
// If we do have an active order, only update if basket changed
if (JSON.stringify(basket) !== JSON.stringify(lastRemoteBasketRef.current)) {
updateDoc(doc(firestore, 'orders', activeOrderId), {
items: basket,
updatedAt: serverTimestamp(),
})
.then(() => {
lastRemoteBasketRef.current = basket;
})
.catch(error => {
console.error(`Error updating order ${activeOrderId}`, error);
});
}
}
}, 500);
return () => clearTimeout(timeoutId);
}, [basket, activeOrderId, user.uid]);
// ------------------------------------------------------------------
//  Filter logic
// ------------------------------------------------------------------
const distinctCategories = Array.from(new Set(products.map(p => p.category))).sort();
const distinctSuppliers = Array.from(new Set(products.map(p => p.supplier))).sort();
// Filter products based on the states
const filteredProducts = products.filter(product => {
const matchesSearch = product.name
.toLowerCase()
.includes(searchTerm.toLowerCase());
const matchesCategory = selectedCategory
? product.category === selectedCategory
: true;
const matchesSupplier = selectedSupplier
? product.supplier === selectedSupplier
: true;
const matchesBio = bioOnly ? product.bio === true : true;
return matchesSearch && matchesCategory && matchesSupplier && matchesBio;
});
// ------------------------------------------------------------------
//  CUSTOM SORT: FRUITS -> LEGUMES -> everything else
// ------------------------------------------------------------------
const categoryPriority = {
FRUITS: 1,
LEGUMES: 2,
};
const sortedFilteredProducts = [...filteredProducts].sort((a, b) => {
const catA = (a.category || '').toUpperCase();
const catB = (b.category || '').toUpperCase();
const priorityA = categoryPriority[catA] || 999;  // 999 if not FRUITS or LEGUMES
const priorityB = categoryPriority[catB] || 999;
// First compare priority
if (priorityA !== priorityB) {
return priorityA - priorityB;
}
// If same priority, compare category alphabetically
const catComparison = catA.localeCompare(catB);
if (catComparison !== 0) {
return catComparison;
}
// If same category, compare name alphabetically
return (a.name || '').localeCompare(b.name || '');
});
// ------------------------------------------------------------------
//  Logout handler
// ------------------------------------------------------------------
const handleLogout = async () => {
try {
await signOut(auth);
} catch (error) {
console.error("Error signing out:", error);
}
};
// ------------------------------------------------------------------
//  Render
// ------------------------------------------------------------------
return (
<Container sx={{ pt: 4, pb: 10 }}>
{/* Header / Logo / Buttons */}
<Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'flex-start', mb: 2 }}>
<Box>
<img src={Logo} alt="Logo" style={{ height: '40px', marginBottom: '10px' }} />
<br />
<Button variant="outlined" component={Link} to="/orders" sx={{ mt: 1 }}>
Voir l'historique des commandes
</Button>
</Box>
<Box sx={{ textAlign: 'right' }}>
{user && (
<>
<Typography variant="body1" sx={{ fontWeight: 'bold' }}>
{user.email}
</Typography>
<Button
variant="outlined"
color="secondary"
onClick={handleLogout}
sx={{ mt: 1 }}
>
Log Out
</Button>
{isDelivery && (
<Button variant="outlined" component={Link} to="/delivery" sx={{ mt: 1, ml: 1 }}>
Delivery Dashboard
</Button>
)}
{userAddress && (
<Typography variant="body2" sx={{ color: 'text.secondary' }}>
{userAddress}
</Typography>
)}
<Typography variant="body2" sx={{ color: 'text.secondary', mt: 1 }}>
Semaine: {currentWeek}
</Typography>
</>
)}
</Box>
</Box>
{/* Filter Bar (with mobile dialog) */}
<FilterBar
searchTerm={searchTerm}
setSearchTerm={setSearchTerm}
selectedCategory={selectedCategory}
setSelectedCategory={setSelectedCategory}
selectedSupplier={selectedSupplier}
setSelectedSupplier={setSelectedSupplier}
bioOnly={bioOnly}
setBioOnly={setBioOnly}
distinctCategories={distinctCategories}
distinctSuppliers={distinctSuppliers}
/>
{/* Product list/table (responsive) */}
<Box className="table-container">
<ResponsiveProductsView
products={sortedFilteredProducts}
addToBasket={addToBasket}
/>
</Box>
{/* Basket (at bottom) */}
<Basket
basket={basket}
updateBasketItem={updateBasketItem}
updateBasketItemComment={updateBasketItemComment}
removeBasketItem={removeBasketItem}
saveOrder={saveOrder}
isOrderAllowed={isOrderAllowed}
/>
</Container>
);
}
export default ProductsPage;



# ** File: src/hooks/useDeliveryAggregation.js **
// src/hooks/useDeliveryAggregation.js
import { useEffect, useState } from 'react';
import { collection, query, where, onSnapshot, doc, getDoc } from 'firebase/firestore';
import { firestore } from '../firebase';
import { getWeekCode } from '../utils/dateUtils';
/**
* A custom hook that fetches and aggregates orders, plus checks for supplier invoices.
* Returns { orders, aggregatedBySupplier, supplierInvoiceUrl, reloadInvoices }
*/
export function useDeliveryAggregation() {
const [orders, setOrders] = useState([]);
const [aggregatedBySupplier, setAggregatedBySupplier] = useState({});
const [supplierInvoiceUrl, setSupplierInvoiceUrl] = useState({});
const currentWeek = getWeekCode(new Date());
// 1) Fetch orders for current week
useEffect(() => {
const wc = getWeekCode(new Date());
const ordersRef = collection(firestore, 'orders');
const qOrders = query(ordersRef, where('weekCode', '==', wc));
const unsub = onSnapshot(qOrders, (snapshot) => {
const data = snapshot.docs.map(d => ({ id: d.id, ...d.data() }));
setOrders(data);
});
return () => unsub();
}, []);
// 2) Recompute aggregatedBySupplier whenever orders changes
useEffect(() => {
const newAggregated = {};
orders.forEach(order => {
if (order.items) {
order.items.forEach(item => {
const supplier = item.supplier || 'Unknown';
if (!newAggregated[supplier]) {
newAggregated[supplier] = {};
}
if (!newAggregated[supplier][item.id]) {
newAggregated[supplier][item.id] = { ...item };
} else {
newAggregated[supplier][item.id].quantity += item.quantity;
}
});
}
});
setAggregatedBySupplier(newAggregated);
}, [orders]);
// 3) Check if there's an uploaded invoice in Firestore for each supplier
//    Provide a function so we can reload if needed
async function reloadInvoices(aggregatedObj) {
for (const supplier of Object.keys(aggregatedObj)) {
const docId = `${currentWeek}_${supplier}`;
const invoiceDocRef = doc(firestore, 'delivery_invoices', docId);
const snapshot = await getDoc(invoiceDocRef);
if (snapshot.exists()) {
const data = snapshot.data();
if (data.invoiceUrl) {
setSupplierInvoiceUrl((prev) => ({
...prev,
[supplier]: data.invoiceUrl
}));
}
}
}
}
useEffect(() => {
reloadInvoices(aggregatedBySupplier);
// eslint-disable-next-line react-hooks/exhaustive-deps
}, [aggregatedBySupplier]);
return {
orders,
aggregatedBySupplier,
supplierInvoiceUrl,
reloadInvoices,
currentWeek,
};
}

