# Combined source code for commit: 123
# Generated on: 2025-04-02 06:37:58



# ** File: functions/index.js **
// functions/index.js
const { onDocumentWritten } = require('firebase-functions/v2/firestore');
const { logger } = require('firebase-functions');
const admin = require('firebase-admin');
admin.initializeApp();
const db = admin.firestore();
/**
* Helper function to fetch the margin from Firestore.
* Returns 0 if no margin is set.
*/
async function getMargin() {
const marginSnap = await db.collection('settings').doc('sales').get();
return marginSnap.exists ? marginSnap.data().margin || 0 : 0;
}
/**
* Helper function to apply the margin to a given base price.
* @param {number} basePrice - The original price.
* @param {number} margin - The margin percentage.
* @returns {number} The final price.
*/
function applyMargin(basePrice, margin) {
return basePrice * (1 + margin / 100);
}
/**
* Cloud Function to update all non-delivered orders with a new price (or revert to default).
*/
exports.applyPriceChangeToAllOrders = onDocumentWritten(
{ document: 'delivery_checklist/{docId}' },
async (event) => {
if (!event.data.after) {
return null;
}
const oldData = event.data.before?.data() || {};
const newData = event.data.after.data() || {};
if (!newData.productId) {
logger.info('No productId in new data, skipping...');
return null;
}
const weekCode = newData.weekCode;
if (!weekCode) {
logger.info('No weekCode in new data, skipping...');
return null;
}
const productId = newData.productId;
const newPriceIsNumeric = typeof newData.newPrice === 'number';
const oldPriceIsNumeric = typeof oldData.newPrice === 'number';
if (newData.newPrice === oldData.newPrice) {
logger.info('newPrice did not change, skipping...');
return null;
}
let priceToApply;
if (newPriceIsNumeric) {
priceToApply = newData.newPrice;
logger.info(`Applying new base price ${priceToApply} for product ${productId}`);
} else {
if (!oldPriceIsNumeric) {
logger.info('newPrice is not numeric and no prior override, skipping revert.');
return null;
}
const productSnap = await db.collection('products').doc(productId).get();
if (!productSnap.exists) {
logger.info(`Product ${productId} not found; cannot revert price.`);
return null;
}
priceToApply = productSnap.data().price;
logger.info(`Reverting price for product ${productId} to base price ${priceToApply}`);
}
// Fetch the margin and apply it
const margin = await getMargin();
priceToApply = applyMargin(priceToApply, margin);
const ordersSnap = await db.collection('orders').where('weekCode', '==', weekCode).get();
if (ordersSnap.empty) {
logger.info(`No orders found for weekCode=${weekCode} to update.`);
return null;
}
const relevantDocs = ordersSnap.docs.filter((docSnap) => {
const data = docSnap.data();
return data.deliveryStatus !== 'delivered';
});
if (relevantDocs.length === 0) {
logger.info('All orders are delivered or none matching. Nothing to update.');
return null;
}
const batch = db.batch();
relevantDocs.forEach((orderDoc) => {
const orderData = orderDoc.data();
if (!Array.isArray(orderData.items) || orderData.items.length === 0) return;
let changed = false;
const updatedItems = orderData.items.map((item) => {
if (item.id === productId) {
changed = true;
return { ...item, price: priceToApply };
}
return item;
});
if (changed) {
batch.update(orderDoc.ref, {
items: updatedItems,
updatedAt: admin.firestore.FieldValue.serverTimestamp(),
});
}
});
if (batch._ops.length === 0) {
logger.info('No items needed updating in non-delivered orders.');
return null;
}
await batch.commit();
logger.info(`Successfully updated non-delivered orders for product ${productId} with final price ${priceToApply}.`);
return null;
}
);



# ** File: src/reportWebVitals.js **
const reportWebVitals = onPerfEntry => {
if (onPerfEntry && onPerfEntry instanceof Function) {
import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {
getCLS(onPerfEntry);
getFID(onPerfEntry);
getFCP(onPerfEntry);
getLCP(onPerfEntry);
getTTFB(onPerfEntry);
});
}
};
export default reportWebVitals;



# ** File: src/App.css **
.App {
text-align: center;
}
.App-logo {
height: 40vmin;
pointer-events: none;
}
@media (prefers-reduced-motion: no-preference) {
.App-logo {
animation: App-logo-spin infinite 20s linear;
}
}
.App-header {
background-color: #282c34;
min-height: 100vh;
display: flex;
flex-direction: column;
align-items: center;
justify-content: center;
font-size: calc(10px + 2vmin);
color: white;
}
.App-link {
color: #61dafb;
}
@keyframes App-logo-spin {
from {
transform: rotate(0deg);
}
to {
transform: rotate(360deg);
}
}



# ** File: src/index.js **
import React from 'react';
import ReactDOM from 'react-dom/client';
import App from './App';
import './index.css';
import { createTheme, ThemeProvider } from '@mui/material/styles';
import { PricingProvider } from './contexts/PricingContext';
const theme = createTheme({
typography: {
fontFamily: 'Space Grotesk, sans-serif',
},
});
const root = ReactDOM.createRoot(document.getElementById('root'));
root.render(
<React.StrictMode>
<ThemeProvider theme={theme}>
<PricingProvider>
<App />
</PricingProvider>
</ThemeProvider>
</React.StrictMode>
);



# ** File: src/index.css **
@import url('https://fonts.googleapis.com/css2?family=Space+Grotesk:wght@400;500;700&display=swap');
html, body {
height: 100%;
background-color: #F5F3EB; /* Adjust to match the site */
font-family: 'Space Grotesk', sans-serif !important; /* <— updated font */
color: #2D2A26;
}
.container {
max-width: 1200px;
margin: auto;
padding: 2rem;
}
.table-container {
height: calc(100vh - 150px); /* Adjust based on header height */
overflow-y: auto;
border-radius: 10px;
background: white;
}



# ** File: src/App.test.js **
import { render, screen } from '@testing-library/react';
import App from './App';
test('renders learn react link', () => {
render(<App />);
const linkElement = screen.getByText(/learn react/i);
expect(linkElement).toBeInTheDocument();
});



# ** File: src/setupTests.js **
// jest-dom adds custom jest matchers for asserting on DOM nodes.
// allows you to do things like:
// expect(element).toHaveTextContent(/react/i)
// learn more: https://github.com/testing-library/jest-dom
import '@testing-library/jest-dom';



# ** File: src/firebase.js **
import { initializeApp } from 'firebase/app';
import { getAuth } from 'firebase/auth';
import { getFirestore, serverTimestamp } from 'firebase/firestore';
// ADD this import for Storage:
import { getStorage } from 'firebase/storage';
const firebaseConfig = {
apiKey: "AIzaSyAuaXIWX2K08mapzxi0OT7H4pkfnb1WpW4",
authDomain: "ecorce-dev.firebaseapp.com",
projectId: "ecorce-dev",
storageBucket: "ecorce-dev.firebasestorage.app",
messagingSenderId: "1096630557135",
appId: "1:1096630557135:web:94434d5275a2a64e08daba",
measurementId: "G-6K6XZHY6VZ"
};
const app = initializeApp(firebaseConfig);
const auth = getAuth(app);
const firestore = getFirestore(app);
// Export storage:
const storage = getStorage(app);
export { app, auth, firestore, storage, serverTimestamp };



# ** File: src/App.js **
// src/App.js
import React, { useEffect, useState } from 'react';
import { auth, firestore } from './firebase';
import { doc, getDoc } from 'firebase/firestore';
import { BrowserRouter as Router, Routes, Route, Navigate } from 'react-router-dom';
import Login from './components/Login';
import ProductsPage from './components/ProductsPage';
import OrderHistory from './components/OrderHistory';
import DeliveryDashboard from './components/DeliveryDashboard';
import ProductsManager from './components/ProductsManager'; // NEW: Products Manager for admins
function App() {
const [user, setUser] = useState(null);
const [isDelivery, setIsDelivery] = useState(false);
const [isAdmin, setIsAdmin] = useState(false); // admin flag
const [loading, setLoading] = useState(true); // loading state
useEffect(() => {
const unsub = auth.onAuthStateChanged(async (u) => {
setUser(u);
if (u) {
// Fetch the user document from Firestore
const userDocRef = doc(firestore, 'users', u.uid);
const snap = await getDoc(userDocRef);
if (snap.exists()) {
const data = snap.data();
setIsDelivery(data.delivery === true);
setIsAdmin(data.admin === true); // set admin flag based on user doc
} else {
setIsDelivery(false);
setIsAdmin(false);
}
} else {
setIsDelivery(false);
setIsAdmin(false);
}
setLoading(false);
});
return () => unsub();
}, []);
if (loading) {
// Render a loading indicator until auth and user data are loaded
return <div>Loading...</div>;
}
return (
<Router>
<Routes>
{/* Public route for login */}
<Route path="/login" element={user ? <Navigate to="/" /> : <Login />} />
{/* Normal user route */}
<Route
path="/"
element={user ? <ProductsPage user={user} isDelivery={isDelivery} /> : <Navigate to="/login" />}
/>
<Route path="/orders" element={user ? <OrderHistory user={user} /> : <Navigate to="/login" />} />
{/* Delivery route */}
<Route
path="/delivery"
element={user && isDelivery ? <DeliveryDashboard user={user} isAdmin={isAdmin} /> : <Navigate to="/" />}
/>
{/* Admin Products Manager route */}
<Route
path="/admin/products"
element={user && isAdmin ? <ProductsManager user={user} /> : <Navigate to="/" />}
/>
{/* Fallback route */}
<Route path="*" element={<Navigate to="/" />} />
</Routes>
</Router>
);
}
export default App;



# ** File: src/contexts/PricingContext.js **
// src/contexts/PricingContext.js
import React, { createContext, useContext } from 'react';
import { useMargin } from '../hooks/useMargin';
import { applyMargin } from '../utils/pricing';
const PricingContext = createContext({
margin: 0,
getFinalPrice: (price) => price,
});
export const PricingProvider = ({ children }) => {
const margin = useMargin();
const getFinalPrice = (basePrice) => applyMargin(basePrice, margin);
return (
<PricingContext.Provider value={{ margin, getFinalPrice }}>
{children}
</PricingContext.Provider>
);
};
export const usePricing = () => useContext(PricingContext);



# ** File: src/utils/formatPrice.js **
// src/utils/formatPrice.js
import { applyMargin } from './pricing';
/**
* Formats a given price by applying the margin percentage.
* @param {number} value - The base price.
* @param {number} [margin=0] - The margin percentage to apply.
* @returns {string} The final price formatted to two decimal places.
*/
export function formatPrice(value, margin = 0) {
const padded = applyMargin(value, margin);
return padded.toFixed(2);
}



# ** File: src/utils/pdfUtils.js **
// src/utils/pdfUtils.js
import jsPDF from 'jspdf';
import autoTable from 'jspdf-autotable';
// 1) Import your local logo image
import logo from '../logo.png';
/**
* Exports a PDF with items sorted alphabetically by 'name',
* plus a custom header with the site logo and a final total line.
*
* @param {Array} aggregatedItemsArray - The array of aggregated items.
* @param {string} currentWeek - The current week code.
* @param {string} supplierLabel - The supplier name label.
*/
export function exportAggregatedPDF(aggregatedItemsArray, currentWeek, supplierLabel) {
// Sort items by name
const sortedItems = [...aggregatedItemsArray].sort((a, b) => {
const nameA = (a.name || '').toLowerCase();
const nameB = (b.name || '').toLowerCase();
return nameA.localeCompare(nameB);
});
// Create a new PDF document
const doc = new jsPDF();
// 2) Insert the logo at top-left corner
//    x=10, y=10, width=30, height auto (approx)
doc.addImage(logo, 'PNG', 10, 10, 30, 0);
// Optionally, add a horizontal line or some text offset
doc.setLineWidth(0.5);
// Draw a line from x=10 to x=200 at y=25
doc.line(10, 25, 200, 25);
// 3) Add main title or text below the logo/line
let startY = 35; // move content down so it doesn't overlap
doc.setFontSize(16);
doc.text(`Produits agrégés – Semaine ${currentWeek}`, 14, startY);
startY += 10;
doc.setFontSize(12);
if (supplierLabel) {
doc.text(`Fournisseur: ${supplierLabel}`, 14, startY);
startY += 10;
}
// 4) Prepare columns
const columns = [
{ header: 'ID - Nom', dataKey: 'name' },
{ header: 'Qtée', dataKey: 'quantity' },
{ header: 'Prix', dataKey: 'price' },
{ header: 'Total', dataKey: 'total' },
];
// 5) Prepare row data for autoTable
const rows = sortedItems.map((item) => ({
name: `ID: ${item.id} - ${item.name}`,
quantity: item.quantity,
price: `$${parseFloat(item.price).toFixed(2)}`,
total: `$${(item.price * item.quantity).toFixed(2)}`,
}));
// 6) Use autoTable, starting below the header
autoTable(doc, {
startY: startY, // use the updated startY
head: [columns.map((col) => col.header)],
body: rows.map((row) => columns.map((col) => row[col.dataKey])),
styles: { fontSize: 10 },
headStyles: { fillColor: [41, 128, 185] },
margin: { horizontal: 14 },
});
// Calculate the total aggregated cost
const total = sortedItems.reduce((acc, item) => acc + item.price * item.quantity, 0);
// 7) Add a total line below the table
const finalY = doc.lastAutoTable.finalY || startY;
doc.setFontSize(12);
// Optionally set font to bold for the total line
doc.setFont(undefined, 'bold');
doc.text(`Total: $${total.toFixed(2)}`, 14, finalY + 10);
// 8) Save the PDF
doc.save(`aggregated_products_week_${currentWeek}${supplierLabel ? `_${supplierLabel}` : ''}.pdf`);
}



# ** File: src/utils/dateUtils.js **
// src/utils/dateUtils.js
export function getWeekCode(date) {
const target = new Date(date);
const dayNr = (target.getDay() + 6) % 7; // Monday = 0
target.setDate(target.getDate() - dayNr + 3);
const firstThursday = new Date(target.getFullYear(), 0, 4);
const diff = target - firstThursday;
const weekNumber = 1 + Math.round(diff / (7 * 24 * 3600 * 1000));
return `${weekNumber < 10 ? '0' + weekNumber : weekNumber}-${target.getFullYear()}`;
}



# ** File: src/utils/pricing.js **
// src/utils/pricing.js
/**
* Given a base price and a margin percentage, return the final price.
* @param {number} basePrice - The original price.
* @param {number} margin - The margin percentage (e.g., 10 for 10%).
* @returns {number} The final price.
*/
export function applyMargin(basePrice, margin) {
return basePrice * (1 + margin / 100);
}



# ** File: src/components/AddProductDialog.js **
// src/components/AddProductDialog.js
import React, { useState, useEffect } from 'react';
import { collection, query, where, onSnapshot, addDoc } from 'firebase/firestore';
import { firestore } from '../firebase';
import {
Dialog,
DialogTitle,
DialogContent,
DialogActions,
TextField,
List,
ListItem,
ListItemText,
Button,
Box,
FormControl,
InputLabel,
Select,
MenuItem
} from '@mui/material';
export default function AddProductDialog({ open, onClose, onProductSelect, defaultMode }) {
// Use defaultMode prop (if provided) or default to "select"
const [mode, setMode] = useState(defaultMode || 'select');
const [searchTerm, setSearchTerm] = useState('');
const [products, setProducts] = useState([]);
// State for manual product form
const [newProduct, setNewProduct] = useState({
name: '',
code: '',
price: '',
supplier: ''
});
const [loading, setLoading] = useState(false);
useEffect(() => {
setMode(defaultMode || 'select');
setSearchTerm('');
setNewProduct({ name: '', code: '', price: '', supplier: '' });
}, [open, defaultMode]);
// Fetch available products (for select mode)
useEffect(() => {
const productsRef = collection(firestore, 'products');
const q = query(productsRef, where('available', '==', true));
const unsubscribe = onSnapshot(q, snapshot => {
const prods = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
prods.sort((a, b) => {
if (a.manuallyAdded && !b.manuallyAdded) return -1;
if (!a.manuallyAdded && b.manuallyAdded) return 1;
return a.name.localeCompare(b.name);
});
setProducts(prods);
});
return () => unsubscribe();
}, []);
// Filter products based on search term (only in select mode)
const filteredProducts = products.filter(product =>
product.name.toLowerCase().includes(searchTerm.toLowerCase())
);
// Handler for manual product submission (creation)
const handleManualSubmit = async (e) => {
e.preventDefault();
setLoading(true);
try {
const newProdData = {
...newProduct,
price: parseFloat(newProduct.price) || 0,
available: true,
manuallyAdded: true
};
const docRef = await addDoc(collection(firestore, 'products'), newProdData);
const createdProduct = { id: docRef.id, ...newProdData };
onProductSelect(createdProduct);
setNewProduct({ name: '', code: '', price: '', supplier: '' });
setMode('select');
} catch (error) {
console.error("Error adding new product", error);
} finally {
setLoading(false);
}
};
return (
<Dialog open={open} onClose={onClose} fullWidth maxWidth="sm">
<DialogTitle>
{mode === 'select' ? 'Ajouter un produit' : 'Ajouter un produit manuellement'}
</DialogTitle>
<DialogContent>
{mode === 'select' ? (
<>
<TextField
label="Rechercher"
variant="outlined"
fullWidth
margin="normal"
value={searchTerm}
onChange={(e) => setSearchTerm(e.target.value)}
/>
<List>
{filteredProducts.map(product => (
<ListItem
button
key={product.id}
onClick={() => onProductSelect(product)}
>
<ListItemText
primary={product.name}
secondary={`Prix: $${parseFloat(product.price).toFixed(2)}`}
/>
</ListItem>
))}
</List>
</>
) : (
<form onSubmit={handleManualSubmit}>
<TextField
label="Nom du produit"
variant="outlined"
fullWidth
margin="normal"
value={newProduct.name}
onChange={(e) => setNewProduct({ ...newProduct, name: e.target.value })}
required
/>
<TextField
label="Code du produit"
variant="outlined"
fullWidth
margin="normal"
value={newProduct.code}
onChange={(e) => setNewProduct({ ...newProduct, code: e.target.value })}
/>
<TextField
label="Prix"
variant="outlined"
fullWidth
margin="normal"
type="number"
value={newProduct.price}
onChange={(e) => setNewProduct({ ...newProduct, price: e.target.value })}
required
/>
<FormControl fullWidth margin="normal">
<InputLabel>Fournisseur</InputLabel>
<Select
label="Fournisseur"
value={newProduct.supplier}
onChange={(e) => setNewProduct({ ...newProduct, supplier: e.target.value })}
required
>
<MenuItem value="Big Block">Big Block</MenuItem>
<MenuItem value="canadawide">canadawide</MenuItem>
</Select>
</FormControl>
<Box sx={{ display: 'flex', justifyContent: 'space-between', mt: 2 }}>
<Button onClick={() => setMode('select')} color="primary">
Retour
</Button>
<Button type="submit" variant="contained" color="primary" disabled={loading}>
{loading ? "En cours..." : "Ajouter"}
</Button>
</Box>
</form>
)}
</DialogContent>
{mode === 'select' && (
<DialogActions>
<Button onClick={() => setMode('manual')} variant="contained" color="primary">
Ajouter un produit manuellement
</Button>
<Button onClick={onClose}>Annuler</Button>
</DialogActions>
)}
</Dialog>
);
}



# ** File: src/components/FilterBar.js **
// src/components/FilterBar.js
import React, { useState } from 'react';
import { useTheme } from '@mui/material/styles';
import useMediaQuery from '@mui/material/useMediaQuery';
import {
Box,
Button,
Dialog,
DialogTitle,
DialogContent,
DialogActions,
TextField,
FormControl,
InputLabel,
Select,
MenuItem,
FormControlLabel,
Checkbox,
Typography,
} from '@mui/material';
/**
* A small dialog for mobile screens: user can pick filters.
*/
function MobileFiltersDialog({
open,
onClose,
searchTerm,
setSearchTerm,
selectedCategory,
setSelectedCategory,
selectedSupplier,
setSelectedSupplier,
bioOnly,
setBioOnly,
distinctCategories,
distinctSuppliers,
}) {
return (
<Dialog open={open} onClose={onClose} fullWidth>
<DialogTitle>Filtrer</DialogTitle>
<DialogContent dividers>
<TextField
label="Rechercher"
variant="outlined"
fullWidth
value={searchTerm}
onChange={(e) => setSearchTerm(e.target.value)}
sx={{ mt: 2 }}
/>
<FormControl sx={{ width: '100%', mt: 2 }}>
<InputLabel>Catégorie</InputLabel>
<Select
value={selectedCategory}
onChange={(e) => setSelectedCategory(e.target.value)}
label="Catégorie"
>
<MenuItem value="">Toutes</MenuItem>
{distinctCategories.map((cat) => (
<MenuItem key={cat} value={cat}>
{cat}
</MenuItem>
))}
</Select>
</FormControl>
<FormControl sx={{ width: '100%', mt: 2 }}>
<InputLabel>Fournisseur</InputLabel>
<Select
value={selectedSupplier}
onChange={(e) => setSelectedSupplier(e.target.value)}
label="Fournisseur"
>
<MenuItem value="">Tous</MenuItem>
{distinctSuppliers.map((sup) => (
<MenuItem key={sup} value={sup}>
{sup}
</MenuItem>
))}
</Select>
</FormControl>
<FormControlLabel
sx={{ mt: 2 }}
control={
<Checkbox
checked={bioOnly}
onChange={(e) => setBioOnly(e.target.checked)}
/>
}
label="Bio seulement"
/>
</DialogContent>
<DialogActions>
<Button onClick={onClose}>Fermer</Button>
</DialogActions>
</Dialog>
);
}
/**
* FilterBar decides:
* - On mobile: show a single "Filtrer" button -> opens MobileFiltersDialog
* - On larger screens: show the filters inline
*/
export default function FilterBar({
searchTerm,
setSearchTerm,
selectedCategory,
setSelectedCategory,
selectedSupplier,
setSelectedSupplier,
bioOnly,
setBioOnly,
distinctCategories,
distinctSuppliers,
}) {
const theme = useTheme();
const isMobile = useMediaQuery(theme.breakpoints.down('sm'));
// State for opening the mobile dialog
const [dialogOpen, setDialogOpen] = useState(false);
if (!isMobile) {
// --- Desktop / Tablet Layout (filters inline) ---
return (
<Box sx={{ display: 'flex', gap: 2, alignItems: 'center', mb: 2, flexWrap: 'wrap' }}>
<TextField
label="Rechercher"
variant="outlined"
value={searchTerm}
onChange={(e) => setSearchTerm(e.target.value)}
sx={{ minWidth: 200 }}
/>
<FormControl sx={{ minWidth: 160 }}>
<InputLabel>Catégorie</InputLabel>
<Select
value={selectedCategory}
onChange={(e) => setSelectedCategory(e.target.value)}
label="Catégorie"
>
<MenuItem value="">Toutes</MenuItem>
{distinctCategories.map((cat) => (
<MenuItem key={cat} value={cat}>
{cat}
</MenuItem>
))}
</Select>
</FormControl>
<FormControl sx={{ minWidth: 160 }}>
<InputLabel>Fournisseur</InputLabel>
<Select
value={selectedSupplier}
onChange={(e) => setSelectedSupplier(e.target.value)}
label="Fournisseur"
>
<MenuItem value="">Tous</MenuItem>
{distinctSuppliers.map((sup) => (
<MenuItem key={sup} value={sup}>
{sup}
</MenuItem>
))}
</Select>
</FormControl>
<FormControlLabel
control={
<Checkbox
checked={bioOnly}
onChange={(e) => setBioOnly(e.target.checked)}
/>
}
label="Bio seulement"
/>
</Box>
);
}
// --- Mobile Layout (dialog) ---
return (
<>
<Button
variant="outlined"
onClick={() => setDialogOpen(true)}
sx={{ mb: 2 }}
>
Filtrer
</Button>
<MobileFiltersDialog
open={dialogOpen}
onClose={() => setDialogOpen(false)}
searchTerm={searchTerm}
setSearchTerm={setSearchTerm}
selectedCategory={selectedCategory}
setSelectedCategory={setSelectedCategory}
selectedSupplier={selectedSupplier}
setSelectedSupplier={setSelectedSupplier}
bioOnly={bioOnly}
setBioOnly={setBioOnly}
distinctCategories={distinctCategories}
distinctSuppliers={distinctSuppliers}
/>
</>
);
}



# ** File: src/components/SignatureOverlay.js **
// src/components/SignatureOverlay.js
import React from 'react';
import { Box, Button, Typography } from '@mui/material';
import SignatureCanvas from 'react-signature-canvas';
export default function SignatureOverlay({
open,
sigPadRef,
onClear,
onSave,
onCancel
}) {
if (!open) return null;
return (
<Box
sx={{
// Make sure this is above MUI dialogs, tables, etc.
position: 'fixed',
top: 0, left: 0, right: 0, bottom: 0,
zIndex: 2000,               // <--- NEW: ensure this is on top
backgroundColor: 'rgba(0,0,0,0.5)',
display: 'flex',
justifyContent: 'center',
alignItems: 'center'
}}
>
<Box sx={{ backgroundColor: '#fff', p: 2, borderRadius: 2 }}>
<Typography variant="h6" gutterBottom>
Signature
</Typography>
<SignatureCanvas
ref={sigPadRef}
penColor="black"
// Set backgroundColor to solid white if you do not want to see anything behind
backgroundColor="#fff"  // <--- NEW: opaque background
canvasProps={{ width: 400, height: 200, className: 'sigCanvas' }}
/>
<Box sx={{ mt: 2, display: 'flex', gap: 2 }}>
<Button variant="outlined" onClick={onClear}>
Effacer
</Button>
<Button variant="contained" onClick={onSave}>
Enregistrer la signature
</Button>
<Button variant="text" onClick={onCancel}>
Annuler
</Button>
</Box>
</Box>
</Box>
);
}



# ** File: src/components/OrderHistory.js **
// src/components/OrderHistory.js
import React, { useState, useEffect } from 'react';
import { collection, query, where, orderBy, onSnapshot } from 'firebase/firestore';
import { firestore } from '../firebase';
import { Link as RouterLink } from 'react-router-dom';
import { usePricing } from '../contexts/PricingContext';
import { formatPrice } from '../utils/formatPrice';
import { Container, Typography, Link, Paper, Box, Chip } from '@mui/material';
function OrderHistory({ user }) {
const [orders, setOrders] = useState([]);
const { getFinalPrice } = usePricing();
useEffect(() => {
const ordersRef = collection(firestore, 'orders');
const q = query(
ordersRef,
where('userId', '==', user.uid),
orderBy('createdAt', 'desc')
);
const unsubscribe = onSnapshot(q, snapshot => {
const ordersData = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
setOrders(ordersData);
});
return () => unsubscribe();
}, [user.uid]);
const getStatusColor = (status) => {
if (status === 'delivered') return 'success';
if (status === 'being delivered') return 'warning';
return 'default';
};
return (
<Container sx={{ py: 4 }}>
<Typography variant="h4" gutterBottom>
Historique des commandes
</Typography>
<Link component={RouterLink} to="/">
Retour aux produits
</Link>
{orders.length === 0 ? (
<Typography sx={{ mt: 2 }}>Aucune commande trouvée.</Typography>
) : (
orders.map(order => {
// Compute total cost using margin-adjusted prices for each item
const totalCost = (order.items || []).reduce((acc, item) => {
const finalPrice = getFinalPrice(item.price);
return acc + finalPrice * item.quantity;
}, 0);
return (
<Paper key={order.id} sx={{ mb: 2, p: 2 }}>
<Typography variant="subtitle1" sx={{ fontWeight: 'bold' }}>
ID de commande: {order.id}
</Typography>
<Typography variant="body2">
<strong>Date:</strong>{' '}
{order.createdAt ? order.createdAt.toDate().toLocaleString() : 'N/A'}
</Typography>
{order.deliveryStatus && (
<Box sx={{ my: 1 }}>
<Chip label={order.deliveryStatus} color={getStatusColor(order.deliveryStatus)} />
</Box>
)}
{order.deliveryStatus === 'delivered' && (
<Typography variant="body2">
<strong>Date de livraison:</strong>{' '}
{order.deliveredAt ? order.deliveredAt.toDate().toLocaleString() : 'N/A'}
</Typography>
)}
<Box sx={{ mt: 1 }}>
<Typography variant="subtitle2" sx={{ mb: 1 }}>
Articles:
</Typography>
<Box
sx={{
display: 'flex',
borderBottom: '1px solid #ccc',
fontWeight: 'bold',
pb: 1,
mb: 1,
}}
>
<Box sx={{ flex: 1 }}>ID</Box>
<Box sx={{ flex: 2 }}>Name</Box>
<Box sx={{ width: 80, textAlign: 'right' }}>Quantity</Box>
<Box sx={{ width: 80, textAlign: 'right' }}>Price</Box>
</Box>
{[...(order.items || [])]
.sort((a, b) => a.name.localeCompare(b.name))
.map(item => {
const finalPrice = getFinalPrice(item.price);
return (
<Box key={item.id} sx={{ mb: 1 }}>
<Box
sx={{
display: 'flex',
alignItems: 'center',
py: 0.5,
borderBottom: '1px dashed #eee',
}}
>
<Box sx={{ flex: 1 }}>{item.id}</Box>
<Box sx={{ flex: 2 }}>{item.name}</Box>
<Box sx={{ width: 80, textAlign: 'right' }}>{item.quantity}</Box>
<Box sx={{ width: 80, textAlign: 'right' }}>
${formatPrice(finalPrice)}
</Box>
</Box>
{item.comment && (
<Typography variant="body2" sx={{ ml: 2, color: 'grey.600', pt: 0.5 }}>
Commentaire: {item.comment}
</Typography>
)}
</Box>
);
})}
</Box>
<Typography variant="body2" sx={{ textAlign: 'right', mt: 2, fontWeight: 'bold' }}>
Total: ${totalCost.toFixed(2)}
</Typography>
</Paper>
);
})
)}
</Container>
);
}
export default OrderHistory;



# ** File: src/components/ProductRow.js **
import React, { useState } from 'react';
import { TableRow, TableCell, TextField, Button } from '@mui/material';
import { formatPrice } from '../utils/formatPrice';
import { usePricing } from '../contexts/PricingContext';
function ProductRow({ product, addToBasket, style, columnWidths }) {
const [quantity, setQuantity] = useState(1);
// Get the pricing functions from context
const { getFinalPrice } = usePricing();
if (!product) {
console.log('[ProductRow] No product found for this row.');
return null;
}
const handleAdd = () => {
addToBasket(product, parseInt(quantity, 10));
setQuantity(1);
};
return (
<TableRow style={style}>
<TableCell sx={{ width: columnWidths.name }}>{product.name}</TableCell>
<TableCell sx={{ width: columnWidths.category }}>{product.category}</TableCell>
<TableCell sx={{ width: columnWidths.bio }}>{product.bio ? "Yes" : "No"}</TableCell>
<TableCell sx={{ width: columnWidths.price }}>
${formatPrice(getFinalPrice(product.price))}
</TableCell>
<TableCell sx={{ width: columnWidths.quantity }}>
<TextField
type="number"
value={quantity}
onChange={e => setQuantity(e.target.value)}
inputProps={{ min: 1 }}
size="small"
sx={{ width: '60px' }}
/>
</TableCell>
<TableCell sx={{ width: columnWidths.add }}>
<Button variant="contained" onClick={handleAdd}>
Ajouter
</Button>
</TableCell>
</TableRow>
);
}
export default ProductRow;



# ** File: src/components/AggregatedTable.js **
// src/components/AggregatedTable.js
import React, { useEffect, useState } from 'react';
import {
Box,
Paper,
Typography,
Button,
TextField
} from '@mui/material';
import { exportAggregatedPDF } from '../utils/pdfUtils';
import { firestore } from '../firebase';
import { collection, query, where, getDocs } from 'firebase/firestore';
import { usePricing } from '../contexts/PricingContext';
import { formatPrice } from '../utils/formatPrice';
import DistributeQuantityDialog from './DistributeQuantityDialog'; // If you have a Distribute dialog
// ^ If you haven't implemented the Distribute dialog, remove that import
// Custom hook: Batch-fetch original prices from products by IDs.
function useOriginalPrices(productIds) {
const [pricesMap, setPricesMap] = useState({});
useEffect(() => {
async function fetchPrices() {
const newMap = {};
if (!productIds || productIds.length === 0) {
setPricesMap(newMap);
return;
}
// Firestore 'in' queries allow a maximum of 10 values.
const chunkSize = 10;
const chunks = [];
for (let i = 0; i < productIds.length; i += chunkSize) {
chunks.push(productIds.slice(i, i + chunkSize));
}
for (const chunk of chunks) {
const q = query(
collection(firestore, 'products'),
where('__name__', 'in', chunk)
);
const snapshot = await getDocs(q);
snapshot.forEach(doc => {
const data = doc.data();
newMap[doc.id] = data.price;
});
}
setPricesMap(newMap);
}
fetchPrices();
}, [productIds]);
return pricesMap;
}
function AggregatedTable({
aggregatedBySupplier,
supplierInvoiceUrl,
handleInvoiceFileChangeAndUpload,
// The next function is now only used for newPrice updates
updateChecklistField,
checklist,
handleOpenReplaceDialog,
currentWeek,
orders // If you pass the orders to handle distribution
}) {
const { getFinalPrice } = usePricing();
// State for controlling the "Distribuer" dialog
const [distributeDialogOpen, setDistributeDialogOpen] = useState(false);
const [currentDistributeProduct, setCurrentDistributeProduct] = useState(null);
const [ordersForDistribution, setOrdersForDistribution] = useState([]);
// Gather all unique product IDs
const productIdsSet = new Set();
Object.keys(aggregatedBySupplier).forEach(supplier => {
const itemsObj = aggregatedBySupplier[supplier];
Object.values(itemsObj).forEach(item => {
productIdsSet.add(item.id);
});
});
const productIds = Array.from(productIdsSet);
const originalPrices = useOriginalPrices(productIds);
if (Object.keys(aggregatedBySupplier).length === 0) {
return <Typography>No aggregated products.</Typography>;
}
// Handler for opening the "Distribuer" dialog
const handleOpenDistributeDialog = (item) => {
// Find all orders that contain this product
const relevantOrders = orders.filter((ord) =>
ord.items?.some((it) => it.id === item.id)
);
setCurrentDistributeProduct(item);
setOrdersForDistribution(relevantOrders);
setDistributeDialogOpen(true);
};
return (
<>
{Object.keys(aggregatedBySupplier)
.sort()
.map((supplier) => {
const itemsObj = aggregatedBySupplier[supplier];
const itemsArray = Object.values(itemsObj).sort((a, b) =>
a.name.localeCompare(b.name)
);
// Compute total cost using margin-adjusted prices
const totalCost = itemsArray.reduce((acc, item) => {
const basePrice =
originalPrices[item.id] !== undefined
? originalPrices[item.id]
: item.price;
const finalPrice = getFinalPrice(basePrice);
return acc + finalPrice * item.quantity;
}, 0);
const handleExportPDF = () => {
exportAggregatedPDF(itemsArray, currentWeek, supplier);
};
return (
<Paper key={supplier} sx={{ mb: 2, p: 2 }}>
<Typography variant="h6" gutterBottom>
Fournisseur: {supplier}
</Typography>
<Button variant="contained" onClick={handleExportPDF} sx={{ mb: 2 }}>
Exporter en PDF
</Button>
{/* Optional: If you want an "Upload Invoice" button or input, you can place it here */}
{/* Table Header Row (no "Collected" column anymore) */}
<Box
sx={{
display: 'grid',
gridTemplateColumns: {
xs: '1fr 1fr',
sm: '1fr 2fr 0.7fr 1fr 1fr 1fr'
},
gap: 1,
mb: 1,
fontWeight: 'bold',
borderBottom: '1px solid #ccc',
pb: 1,
width: '100%'
}}
>
<Typography>ID</Typography>
<Typography>Nom</Typography>
{/* "Qtée" column */}
<Typography sx={{ textAlign: 'right', display: { xs: 'none', sm: 'block' } }}>
Qtée
</Typography>
{/* New Price label */}
<Typography sx={{ textAlign: 'center', display: { xs: 'none', sm: 'block' } }}>
Nouv. Prix
</Typography>
<Typography sx={{ textAlign: 'right', display: { xs: 'none', sm: 'block' } }}>
Orig
</Typography>
<Typography sx={{ textAlign: 'right', display: { xs: 'none', sm: 'block' } }}>
Action
</Typography>
</Box>
{itemsArray.map((item) => {
const basePrice =
originalPrices[item.id] !== undefined
? originalPrices[item.id]
: item.price;
const finalPrice = getFinalPrice(basePrice);
// We'll keep using checklist for newPrice
const newPriceValue = checklist[item.id]?.newPrice ?? '';
return (
<React.Fragment key={item.id}>
<Box
sx={{
display: 'grid',
gridTemplateColumns: {
xs: '1fr 1fr',
sm: '1fr 2fr 0.7fr 1fr 1fr 1fr'
},
alignItems: 'center',
gap: 1,
mb: 1,
width: '100%',
p: 0.5
}}
>
<Typography>{item.id}</Typography>
<Typography>{item.name}</Typography>
{/* Quantity (just display) */}
<Typography
sx={{
textAlign: 'right',
display: { xs: 'none', sm: 'block' }
}}
>
{item.quantity}
</Typography>
{/* New Price field */}
<TextField
label="New Price"
type="number"
size="small"
value={newPriceValue}
onChange={(e) => {
const newVal =
e.target.value === '' ? null : parseFloat(e.target.value);
updateChecklistField(item.id, 'newPrice', newVal);
}}
inputProps={{
min: 0,
style: { textAlign: 'right' },
inputMode: 'decimal',
pattern: '[0-9]*'
}}
sx={{
width: '100%',
maxWidth: { xs: '90px', sm: '100%' },
// Optional highlight if changed
bgcolor:
newPriceValue &&
parseFloat(newPriceValue) !== parseFloat(item.price)
? '#e0f2fe'
: 'transparent'
}}
/>
{/* Display final price with margin */}
<Typography
sx={{
textAlign: 'right',
display: { xs: 'none', sm: 'block' }
}}
>
${formatPrice(finalPrice)}
</Typography>
{/* Action buttons: Remplacer & Distribuer */}
<Box sx={{ display: 'flex', gap: 1 }}>
<Button
variant="outlined"
size="small"
onClick={() => handleOpenReplaceDialog(item.id)}
sx={{ display: { xs: 'none', sm: 'inline-flex' } }}
>
Remplacer
</Button>
<Button
variant="outlined"
size="small"
onClick={() => handleOpenDistributeDialog(item)}
sx={{ display: { xs: 'none', sm: 'inline-flex' } }}
>
Distribuer
</Button>
</Box>
</Box>
{/* Comments (if any) */}
{item.comments &&
item.comments.length > 0 &&
item.comments.map((entry, index) => (
<Typography
key={index}
variant="caption"
sx={{ pl: 2, color: 'grey.600', mb: 0.5 }}
>
Commentaire de {entry.company} : {entry.comment}
</Typography>
))}
</React.Fragment>
);
})}
{/* Total line */}
<Box sx={{ mt: 2, textAlign: 'right', fontWeight: 'bold' }}>
Total: ${totalCost.toFixed(2)}
</Box>
</Paper>
);
})}
{/* The "Distribuer" dialog, if implemented */}
{distributeDialogOpen && currentDistributeProduct && (
<DistributeQuantityDialog
open={distributeDialogOpen}
product={currentDistributeProduct}
orders={ordersForDistribution}
onClose={() => setDistributeDialogOpen(false)}
/>
)}
</>
);
}
export default AggregatedTable;



# ** File: src/components/Login.js **
import React, { useState, useEffect } from 'react';
import { isSignInWithEmailLink, signInWithEmailLink, sendSignInLinkToEmail } from 'firebase/auth';
import { auth } from '../firebase';
import { useLocation } from 'react-router-dom';
import { Container, Typography, TextField, Button, Box, Alert } from '@mui/material';
function Login() {
const [email, setEmail] = useState('');
const [message, setMessage] = useState('');
const location = useLocation();
useEffect(() => {
if (isSignInWithEmailLink(auth, window.location.href)) {
let storedEmail = window.localStorage.getItem('emailForSignIn');
if (!storedEmail) {
storedEmail = window.prompt('Please provide your email for confirmation');
}
signInWithEmailLink(auth, storedEmail, window.location.href)
.then(() => {
window.localStorage.removeItem('emailForSignIn');
})
.catch(error => {
console.error(error);
});
}
}, [location]);
const handleSubmit = async (e) => {
e.preventDefault();
const actionCodeSettings = {
url: window.location.href,
handleCodeInApp: true,
};
try {
await sendSignInLinkToEmail(auth, email, actionCodeSettings);
window.localStorage.setItem('emailForSignIn', email);
setMessage('Lien de connexion envoyé à votre adresse courriel!');
} catch (error) {
console.error(error);
setMessage("Erreur lors de l'envoi du lien de connexion");
}
};
return (
<Container maxWidth="sm">
<Box sx={{ mt: 8, p: 4, boxShadow: 3, borderRadius: 2 }}>
<Typography variant="h4" component="h1" gutterBottom>
Connexion
</Typography>
<form onSubmit={handleSubmit}>
<TextField
fullWidth
label="Email"
variant="outlined"
margin="normal"
type="email"
value={email}
onChange={e => setEmail(e.target.value)}
required
/>
<Button variant="contained" color="primary" type="submit" fullWidth>
Envoyer le lien de connexion
</Button>
</form>
{message && <Alert severity="info" sx={{ mt: 2 }}>{message}</Alert>}
</Box>
</Container>
);
}
export default Login;



# ** File: src/components/NoTag.js **
// NoTag.js
import React from 'react';
const NoTag = React.forwardRef(({ children }, ref) => <>{children}</>);
export default NoTag;



# ** File: src/components/ResponsiveProductsView.js **
// src/components/ResponsiveProductsView.js
import React from 'react';
import { useTheme } from '@mui/material/styles';
import useMediaQuery from '@mui/material/useMediaQuery';
import { List, ListItem, Typography, Box, Button } from '@mui/material';
import VirtualizedProductsTable from './VirtualizedProductsTable';
import { usePricing } from '../contexts/PricingContext';    // <-- NEW
import { formatPrice } from '../utils/formatPrice';          // <-- NEW
function MobileProductsList({ products, addToBasket }) {
const { getFinalPrice } = usePricing();
return (
<List>
{products.map((product) => {
const finalPrice = getFinalPrice(product.price);
const displayPrice = formatPrice(finalPrice);
return (
<ListItem
key={product.id}
sx={{
display: 'flex',
flexDirection: 'column',
alignItems: 'flex-start',
borderBottom: '1px solid #eee'
}}
>
<Typography variant="subtitle1" sx={{ fontWeight: 'bold' }}>
{product.name}
</Typography>
<Typography variant="body2" sx={{ mt: 0.5 }}>
Prix: ${displayPrice}
</Typography>
{product.category && (
<Typography variant="body2" sx={{ color: 'grey.600' }}>
Catégorie: {product.category}
</Typography>
)}
<Box sx={{ mt: 1 }}>
<Button variant="contained" onClick={() => addToBasket(product, 1)}>
Ajouter
</Button>
</Box>
</ListItem>
);
})}
</List>
);
}
export default function ResponsiveProductsView({ products, addToBasket }) {
const theme = useTheme();
const isMobile = useMediaQuery(theme.breakpoints.down('sm'));
if (isMobile) {
return <MobileProductsList products={products} addToBasket={addToBasket} />;
} else {
return <VirtualizedProductsTable products={products} addToBasket={addToBasket} />;
}
}



# ** File: src/components/DeliveredOrderCard.js **
// src/components/DeliveredOrderCard.js
import React, { useState, useEffect } from 'react';
import { Paper, Typography, Box, Button } from '@mui/material';
import { collection, query, where, getDocs } from 'firebase/firestore';
import { firestore } from '../firebase';
import jsPDF from 'jspdf';
import autoTable from 'jspdf-autotable';
// <-- NEW: import your local logo
import logo from '../logo.png';
export default function DeliveredOrderCard({ order }) {
// Only fetching company info and address now; email comes from order.email
const [address, setAddress] = useState(null);
const [companyName, setCompanyName] = useState('');
useEffect(() => {
const fetchPartnerInfo = async () => {
try {
const partnersRef = collection(firestore, 'res_partner');
const qPartners = query(partnersRef, where('email', '==', order.email));
const querySnapshot = await getDocs(qPartners);
if (!querySnapshot.empty) {
const partnerData = querySnapshot.docs[0].data();
setAddress(partnerData.contact_address_complete || '');
setCompanyName(partnerData.company_name || '');
}
} catch (error) {
console.error('Error fetching address/company info', error);
}
};
fetchPartnerInfo();
}, [order.email]);
// 1) Compute total cost
const totalCost = (order.items || []).reduce(
(acc, item) => acc + item.price * item.quantity,
0
);
const printBill = () => {
const doc = new jsPDF();
// 2) Insert the logo at top-left corner
//    x=10, y=10, width=30, height auto (approx)
doc.addImage(logo, 'PNG', 10, 10, 30, 0);
// Optionally, add a horizontal line across the page, same as aggregator
doc.setLineWidth(0.5);
doc.line(10, 25, 200, 25);
// 3) Add main title or text, after the line
let startY = 35; // move content down
doc.setFontSize(16);
doc.text('Delivery Bill', 14, startY);
startY += 10;
// Additional info (order ID, date, etc.)
doc.setFontSize(12);
doc.text(`Order ID: ${order.id}`, 14, startY);
startY += 8;
const deliveredOn = order.deliveredAt
? order.deliveredAt.toDate().toLocaleString()
: 'N/A';
doc.text(`Delivered on: ${deliveredOn}`, 14, startY);
startY += 10;
if (companyName) {
doc.text(`Company: ${companyName}`, 14, startY);
startY += 8;
}
doc.text(`Email: ${order.email}`, 14, startY);
startY += 8;
if (address) {
doc.text(`Address: ${address}`, 14, startY);
startY += 10;
}
// PDF table with four columns: ID, Name, Quantity, and Price
const tableColumns = ['ID', 'Name', 'Quantity', 'Price'];
const tableRows = (order.items || []).map(item => [
item.id,
item.name,
item.quantity.toString(),
`$${parseFloat(item.price).toFixed(2)}`
]);
autoTable(doc, {
startY,
head: [tableColumns],
body: tableRows,
styles: { fontSize: 10 },
headStyles: { fillColor: [41, 128, 185] },
columnStyles: {
2: { halign: 'right' },
3: { halign: 'right' }
}
});
// If there's a signature, place it below the table
let finalY = doc.lastAutoTable.finalY || startY;
if (order.signature) {
doc.text('Signature:', 14, finalY + 15);
doc.addImage(order.signature, 'PNG', 14, finalY + 20, 60, 30);
finalY += 45; // enough space for the signature
} else {
finalY = finalY + 10; // small gap
}
// Optionally, show total cost below the table
doc.setFontSize(12);
doc.setFont('', 'bold');
doc.text(`Total: $${totalCost.toFixed(2)}`, 14, finalY + 10);
// 4) Save the PDF
doc.save(`delivery_bill_order_${order.id}.pdf`);
};
return (
<Paper sx={{ mb: 2, p: 2, backgroundColor: '#f7f7f7' }}>
<Typography variant="subtitle1" sx={{ fontWeight: 'bold' }}>
ID de commande: {order.id}
</Typography>
{/* Display company info */}
{companyName && (
<Typography variant="body2" sx={{ mb: 1 }}>
Compagnie: {companyName}
</Typography>
)}
<Typography variant="body2" sx={{ mb: 1 }}>
Courriel: {order.email}
</Typography>
{address && (
<Typography variant="body2" sx={{ mb: 1 }}>
Adresse: {address}
</Typography>
)}
<Typography variant="body2">
Livré le:{' '}
{order.deliveredAt ? order.deliveredAt.toDate().toLocaleString() : 'N/A'}
</Typography>
{/* Web Interface: Items in columns */}
{(order.items && order.items.length > 0) && (
<Box sx={{ mt: 2 }}>
{/* Header Row */}
<Box sx={{ display: 'flex', borderBottom: '1px solid #ccc', pb: 1, mb: 1 }}>
<Box sx={{ flex: 1, fontWeight: 'bold' }}>ID</Box>
<Box sx={{ flex: 3, fontWeight: 'bold' }}>Nom</Box>
<Box sx={{ flex: 1, fontWeight: 'bold', textAlign: 'right' }}>Quantitée</Box>
<Box sx={{ flex: 1, fontWeight: 'bold', textAlign: 'right' }}>Prix</Box>
</Box>
{/* Data Rows */}
{order.items.map(item => (
<Box key={item.id} sx={{ display: 'flex', borderBottom: '1px dashed #ccc', pb: 1, mb: 1 }}>
<Box sx={{ flex: 1 }}>{item.id}</Box>
<Box sx={{ flex: 3 }}>{item.name}</Box>
<Box sx={{ flex: 1, textAlign: 'right' }}>{item.quantity}</Box>
<Box sx={{ flex: 1, textAlign: 'right' }}>
${parseFloat(item.price).toFixed(2)}
</Box>
</Box>
))}
</Box>
)}
{/* Show total cost in the UI as well */}
<Typography
variant="body2"
sx={{ textAlign: 'right', mt: 2, fontWeight: 'bold' }}
>
Total: ${totalCost.toFixed(2)}
</Typography>
{/* If signature, show it in the UI */}
{order.signature && (
<Box sx={{ mt: 2 }}>
<Typography variant="body2"><strong>Signature:</strong></Typography>
<Box
component="img"
src={order.signature}
alt="Signature"
sx={{ maxWidth: 200, border: '1px solid #ccc', p: 0.5, borderRadius: 1 }}
/>
</Box>
)}
<Button variant="contained" onClick={printBill} sx={{ mt: 2 }}>
Imprimer le bon de livraison
</Button>
</Paper>
);
}



# ** File: src/components/DeliveryDashboard.js **
// src/components/DeliveryDashboard.js
import React, { useState, useEffect, useRef } from 'react';
import {
collection,
query,
where,
onSnapshot,
updateDoc,
setDoc,
doc,
getDoc,
getDocs,
serverTimestamp
} from 'firebase/firestore';
import { firestore, storage } from '../firebase';
import {
ref,
uploadBytesResumable,
getDownloadURL
} from 'firebase/storage';
import {
Box,
Typography,
Button,
Dialog,
DialogTitle,
DialogContent,
DialogActions,
TextField,
Checkbox,
FormControlLabel
} from '@mui/material';
import { Link } from 'react-router-dom'; // Import Link for navigation
import { useDeliveryAggregation } from '../hooks/useDeliveryAggregation';
import AggregatedTable from './AggregatedTable';
import SignatureOverlay from './SignatureOverlay';
import DeliveredOrderCard from './DeliveredOrderCard';
import AddProductDialog from './AddProductDialog';
import OrderCard from './OrderCard';
import { getWeekCode } from '../utils/dateUtils';
/**
* Dialog pour sélectionner les commandes qui contiennent l’ancien produit.
* L’utilisateur peut cocher celles à remplacer.
*/
function ReplaceOrdersSelectionDialog({
open,
ordersForReplacement,
selectedOrders,
setSelectedOrders,
oldProductIdToReplace, // Pour afficher la quantité de l’ancien produit
onClose,
onNext
}) {
if (!open) return null;
const handleToggleOrder = (orderId) => {
if (selectedOrders.includes(orderId)) {
setSelectedOrders(selectedOrders.filter(id => id !== orderId));
} else {
setSelectedOrders([...selectedOrders, orderId]);
}
};
return (
<Dialog open={open} onClose={onClose} fullWidth maxWidth="sm">
<DialogTitle>Sélectionner les commandes à remplacer</DialogTitle>
<DialogContent dividers>
<Typography variant="body2" sx={{ mb: 2 }}>
Les commandes suivantes contiennent l'ancien produit. Sélectionnez celles où vous souhaitez le remplacer.
</Typography>
{ordersForReplacement.length === 0 ? (
<Typography>Aucune commande ne contient l'ancien produit.</Typography>
) : (
ordersForReplacement.map((order) => {
// Trouver l’item qui correspond à l’ancien produit
const matchingItem = order.items.find(
(item) => item.id === oldProductIdToReplace
);
const quantity = matchingItem ? matchingItem.quantity : 0;
return (
<Box key={order.id} sx={{ mb: 1 }}>
<FormControlLabel
control={
<Checkbox
checked={selectedOrders.includes(order.id)}
onChange={() => handleToggleOrder(order.id)}
/>
}
label={`ID de commande : ${order.id} | ${order.email || ''} | Qté : ${quantity}`}
/>
</Box>
);
})
)}
</DialogContent>
<DialogActions>
<Button onClick={onClose} color="secondary">
Annuler
</Button>
<Button
onClick={onNext}
variant="contained"
color="primary"
disabled={ordersForReplacement.length === 0}
>
Suivant
</Button>
</DialogActions>
</Dialog>
);
}
export default function DeliveryDashboard({ user, isAdmin }) {
// Récupération via le hook d’agrégation
const { orders, aggregatedBySupplier, supplierInvoiceUrl, currentWeek } = useDeliveryAggregation();
// --------------------------------------------------
//  Signature pad
// --------------------------------------------------
const [sigPadOpen, setSigPadOpen] = useState(null);
const sigPadRef = useRef(null);
// --------------------------------------------------
//  Factures fournisseurs (invoices)
// --------------------------------------------------
const [supplierInvoiceUrlState, setSupplierInvoiceUrlState] = useState(supplierInvoiceUrl);
// --------------------------------------------------
//  Checklist pour “collected”, “collectedQuantity”, “newPrice”
// --------------------------------------------------
const [checklist, setChecklist] = useState({});
// Charger le checklist depuis Firestore (comme dans l'ancienne version)
useEffect(() => {
const wc = getWeekCode(new Date());
const checklistRef = collection(firestore, 'delivery_checklist');
const qC = query(checklistRef, where('weekCode', '==', wc));
const unsub = onSnapshot(qC, (snapshot) => {
const data = {};
snapshot.docs.forEach((docSnap) => {
const d = docSnap.data();
data[d.productId] = { id: docSnap.id, ...d };
});
setChecklist(data);
});
return () => unsub();
}, []);
// Activer / désactiver “collected” pour un produit
const toggleCollected = async (productId) => {
const wc = getWeekCode(new Date());
if (checklist[productId]) {
// Inverse la valeur “collected”
const newStatus = !checklist[productId].collected;
try {
await updateDoc(doc(firestore, 'delivery_checklist', checklist[productId].id), {
collected: newStatus,
updatedAt: serverTimestamp()
});
} catch (error) {
console.error("Erreur lors de la mise à jour du checklist", error);
}
} else {
// Crée un nouveau document checklist
try {
const newDocRef = doc(collection(firestore, 'delivery_checklist'));
await setDoc(newDocRef, {
weekCode: wc,
productId,
collected: true,
collectedQuantity: null,
newPrice: null,
createdAt: serverTimestamp(),
updatedAt: serverTimestamp()
});
} catch (error) {
console.error("Erreur lors de la création du document checklist", error);
}
}
};
// Mettre à jour un champ du checklist (collectedQuantity ou newPrice)
const updateChecklistField = async (productId, field, value) => {
const wc = getWeekCode(new Date());
const numericValue = value !== null ? value : null;
if (checklist[productId]) {
// Update existing doc
try {
await updateDoc(doc(firestore, 'delivery_checklist', checklist[productId].id), {
[field]: numericValue,
updatedAt: serverTimestamp()
});
} catch (error) {
console.error("Erreur lors de la mise à jour d'un champ du checklist", error);
}
} else {
// Create new doc if nonexistent
try {
const newDocRef = doc(collection(firestore, 'delivery_checklist'));
await setDoc(newDocRef, {
weekCode: wc,
productId,
collected: false,
collectedQuantity: field === 'collectedQuantity' ? numericValue : null,
newPrice: field === 'newPrice' ? numericValue : null,
createdAt: serverTimestamp(),
updatedAt: serverTimestamp()
});
} catch (error) {
console.error("Erreur lors de la création du document checklist", error);
}
}
};
// --------------------------------------------------
//  "Add Product" dialog
// --------------------------------------------------
const [addProductDialogOpen, setAddProductDialogOpen] = useState(false);
const [selectedOrderForProductAddition, setSelectedOrderForProductAddition] = useState(null);
// --------------------------------------------------
//  "Replace Product" feature
// --------------------------------------------------
const [replaceDialogOpen, setReplaceDialogOpen] = useState(false);
const [oldProductIdToReplace, setOldProductIdToReplace] = useState(null);
// Step 2: user picks new product
const [pendingNewProduct, setPendingNewProduct] = useState(null);
// Orders selection dialog
const [replaceOrdersSelectionOpen, setReplaceOrdersSelectionOpen] = useState(false);
const [ordersForReplacement, setOrdersForReplacement] = useState([]);
const [selectedOrdersForReplacement, setSelectedOrdersForReplacement] = useState([]);
// Final confirm
const [replaceConfirmOpen, setReplaceConfirmOpen] = useState(false);
const [ordersAffectedCount, setOrdersAffectedCount] = useState(0);
// --------------------------------------------------
//  Gestion des commandes actives / livrées
// --------------------------------------------------
const activeOrders = orders.filter(o => o.deliveryStatus !== 'delivered');
const deliveredOrders = orders.filter(o => o.deliveryStatus === 'delivered');
const sortedActiveOrders = [...activeOrders].sort((a, b) => (a.email || '').localeCompare(b.email || ''));
const sortedDeliveredOrders = [...deliveredOrders].sort((a, b) => (a.email || '').localeCompare(b.email || ''));
// --------------------------------------------------
//  Invoices
// --------------------------------------------------
const handleInvoiceFileChangeAndUpload = async (supplier, file) => {
try {
const invoiceRef = ref(storage, `invoices/${currentWeek}/${supplier}/${file.name}`);
const uploadTask = uploadBytesResumable(invoiceRef, file);
uploadTask.on(
'state_changed',
() => {},
(error) => {
console.error("Erreur lors du téléversement de la facture :", error);
alert("Erreur lors du téléversement de la facture");
},
async () => {
const downloadURL = await getDownloadURL(uploadTask.snapshot.ref);
const docId = `${currentWeek}_${supplier}`;
await setDoc(
doc(firestore, 'delivery_invoices', docId),
{
weekCode: currentWeek,
invoiceUrl: downloadURL,
updatedAt: serverTimestamp()
},
{ merge: true }
);
setSupplierInvoiceUrlState((prev) => ({
...prev,
[supplier]: downloadURL
}));
}
);
} catch (err) {
console.error("Erreur lors du téléversement de la facture", err);
}
};
// --------------------------------------------------
//  Order item modifications
// --------------------------------------------------
// Mettre à jour la quantité d’un item dans une commande
const handleQuantityChange = async (orderId, itemId, newQty) => {
const order = orders.find(o => o.id === orderId);
if (!order) return;
const updatedItems = (order.items || []).map(item => {
if (item.id === itemId) {
return { ...item, quantity: parseInt(newQty, 10) || 0 };
}
return item;
});
try {
await updateDoc(doc(firestore, 'orders', orderId), {
items: updatedItems,
updatedAt: serverTimestamp()
});
} catch (err) {
console.error("Erreur lors de la mise à jour de la quantité", err);
}
};
// Marquer une commande comme livrée
const markAsDelivered = async (orderId) => {
try {
await updateDoc(doc(firestore, 'orders', orderId), {
deliveryStatus: 'delivered',
deliveredAt: serverTimestamp()
});
} catch (err) {
console.error("Erreur lors du marquage de la commande comme livrée", err);
}
};
// --------------------------------------------------
//  Signature
// --------------------------------------------------
const openSignaturePad = (orderId) => {
setSigPadOpen(orderId);
};
const clearSignature = () => {
sigPadRef.current?.clear();
};
const saveSignature = async () => {
if (!sigPadRef.current) return;
const orderId = sigPadOpen;
const signatureDataUrl = sigPadRef.current.toDataURL('image/png');
try {
await updateDoc(doc(firestore, 'orders', orderId), {
signature: signatureDataUrl,
updatedAt: serverTimestamp()
});
setSigPadOpen(null);
} catch (err) {
console.error("Erreur lors de l'enregistrement de la signature", err);
}
};
// --------------------------------------------------
//  "Add Product" to Order
// --------------------------------------------------
const handleOpenAddProduct = (orderId) => {
setSelectedOrderForProductAddition(orderId);
setAddProductDialogOpen(true);
};
const handleCloseAddProduct = () => {
setAddProductDialogOpen(false);
setSelectedOrderForProductAddition(null);
};
const handleAddProductToOrder = async (orderId, product) => {
const order = orders.find(o => o.id === orderId);
if (!order) return;
let newItems = [];
let found = false;
if (order.items) {
newItems = order.items.map(item => {
if (item.id === product.id) {
found = true;
return { ...item, quantity: item.quantity + 1 };
}
return item;
});
} else {
newItems = [];
}
if (!found) {
newItems.push({ ...product, quantity: 1 });
}
try {
await updateDoc(doc(firestore, 'orders', orderId), {
items: newItems,
updatedAt: serverTimestamp()
});
console.log(`Produit « ${product.name} » ajouté à la commande ${orderId}`);
} catch (error) {
console.error("Erreur lors de l'ajout du produit à la commande", error);
}
};
// --------------------------------------------------
//  "Replace Product" Feature
// --------------------------------------------------
// Étape 1 : Choisir le produit à remplacer
const handleOpenReplaceDialog = (oldProductId) => {
setOldProductIdToReplace(oldProductId);
setReplaceDialogOpen(true);
};
const handleCloseReplaceDialog = () => {
setReplaceDialogOpen(false);
setOldProductIdToReplace(null);
};
// Étape 2 : Choisir le nouveau produit dans AddProductDialog
const handleStartReplaceConfirmation = (newProduct) => {
if (!oldProductIdToReplace) return;
// Trouver les commandes contenant l'ancien produit
const relevantOrders = orders.filter(order =>
(order.items || []).some(item => item.id === oldProductIdToReplace)
);
setOrdersForReplacement(relevantOrders);
// Sélectionner toutes par défaut
setSelectedOrdersForReplacement(relevantOrders.map(o => o.id));
setPendingNewProduct(newProduct);
// Fermer la boîte de dialogue de sélection
setReplaceDialogOpen(false);
// Ouvrir la boîte de dialogue “ReplaceOrdersSelection”
setReplaceOrdersSelectionOpen(true);
};
// Étape 3 : l’utilisateur coche les commandes à remplacer
const handleCloseReplaceOrdersSelection = () => {
setReplaceOrdersSelectionOpen(false);
setPendingNewProduct(null);
setOldProductIdToReplace(null);
};
const handleNextFromReplaceOrdersSelection = () => {
// Calculer combien de commandes seront affectées
setOrdersAffectedCount(selectedOrdersForReplacement.length);
setReplaceOrdersSelectionOpen(false);
setReplaceConfirmOpen(true);
};
// Étape 4 : confirmation finale
const handleConfirmReplace = () => {
if (!pendingNewProduct || !oldProductIdToReplace) return;
handleReplaceProductInAllOrders(pendingNewProduct);
setReplaceConfirmOpen(false);
setPendingNewProduct(null);
};
const handleCancelReplace = () => {
setReplaceConfirmOpen(false);
setPendingNewProduct(null);
setOldProductIdToReplace(null);
};
// Étape 5 : faire le remplacement dans toutes les commandes sélectionnées
const handleReplaceProductInAllOrders = async (newProduct) => {
let updatedCount = 0;
// Ne remplacer que dans les commandes sélectionnées
const newOrdersState = orders.map(order => {
if (!selectedOrdersForReplacement.includes(order.id)) {
return order;
}
const items = order.items || [];
let changed = false;
const updatedItems = items.map(item => {
if (item.id === oldProductIdToReplace) {
changed = true;
return {
...item,
id: newProduct.id,
name: newProduct.name,
price: newProduct.price,
supplier: newProduct.supplier || 'Unknown'
};
}
return item;
});
if (changed) {
updatedCount++;
// Mettre à jour Firestore
updateDoc(doc(firestore, 'orders', order.id), {
items: updatedItems,
updatedAt: serverTimestamp()
}).catch(err => {
console.error(`Erreur lors de la mise à jour de la commande ${order.id}`, err);
});
return { ...order, items: updatedItems };
}
return order;
});
console.log(
`Produit ${oldProductIdToReplace} remplacé par ${newProduct.id} dans ${updatedCount} commande(s) sélectionnée(s).`
);
// Réinitialiser
setOldProductIdToReplace(null);
setOrdersForReplacement([]);
setSelectedOrdersForReplacement([]);
};
// --------------------------------------------------
//  Render
// --------------------------------------------------
return (
<Box sx={{ p: 2 }}>
<Typography variant="h4" gutterBottom>
Tableau de bord des livraisons
</Typography>
{/* Admin-only button: visible only if isAdmin prop is true */}
{isAdmin && (
<Button variant="outlined" component={Link} to="/admin/products" sx={{ mb: 2 }}>
Products Manager
</Button>
)}
<Typography variant="body1" gutterBottom>
Commandes pour la semaine : {currentWeek}
</Typography>
{/* Agrégation des articles */}
<Box
sx={{
mt: 4,
border: '1px solid #ccc',
p: 2,
borderRadius: 1,
width: '100%'
}}
>
<Box sx={{ display: 'flex', alignItems: 'center', mb: 2 }}>
<Typography variant="h5" sx={{ ml: 2 }}>
Bons de commandes aux fournisseurs - Semaine {currentWeek}
</Typography>
</Box>
<AggregatedTable
aggregatedBySupplier={aggregatedBySupplier}
supplierInvoiceUrl={supplierInvoiceUrlState}
currentWeek={currentWeek}
checklist={checklist}
toggleCollected={toggleCollected}
updateChecklistField={updateChecklistField}
handleInvoiceFileChangeAndUpload={handleInvoiceFileChangeAndUpload}
handleOpenReplaceDialog={handleOpenReplaceDialog}
orders={orders} // NEW: pass orders for filtering in distribution
/>
</Box>
<Typography variant="h5" sx={{ mt: 4, mb: 2 }}>
Livraisons
</Typography>
{/* Commandes actives */}
{sortedActiveOrders.length === 0 ? (
<Typography>Aucune commande active pour cette semaine.</Typography>
) : (
sortedActiveOrders.map(order => (
<OrderCard
key={order.id}
order={order}
onMarkDelivered={markAsDelivered}
onOpenSignaturePad={openSignaturePad}
onQuantityChange={handleQuantityChange}
onAddProduct={handleOpenAddProduct}
/>
))
)}
{/* Commandes livrées */}
{sortedDeliveredOrders.length > 0 && (
<>
<Typography variant="h5" sx={{ mt: 4, mb: 2 }}>
Commandes livrées
</Typography>
{sortedDeliveredOrders.map(order => (
<DeliveredOrderCard key={order.id} order={order} />
))}
</>
)}
{/* Overlay de signature */}
<SignatureOverlay
open={!!sigPadOpen}
sigPadRef={sigPadRef}
onClear={clearSignature}
onSave={saveSignature}
onCancel={() => setSigPadOpen(null)}
/>
{/* "Add Product" Dialog existant */}
<AddProductDialog
open={addProductDialogOpen}
onClose={handleCloseAddProduct}
onProductSelect={(product) => {
handleAddProductToOrder(selectedOrderForProductAddition, product);
handleCloseAddProduct();
}}
/>
{/* Étape 1 : choisir l’ancien produit à remplacer */}
<AddProductDialog
open={replaceDialogOpen}
onClose={handleCloseReplaceDialog}
onProductSelect={(product) => {
handleStartReplaceConfirmation(product);
}}
/>
{/* Étape 2 : Sélection des commandes où remplacer */}
<ReplaceOrdersSelectionDialog
open={replaceOrdersSelectionOpen}
ordersForReplacement={ordersForReplacement}
selectedOrders={selectedOrdersForReplacement}
setSelectedOrders={setSelectedOrdersForReplacement}
oldProductIdToReplace={oldProductIdToReplace}
onClose={handleCloseReplaceOrdersSelection}
onNext={handleNextFromReplaceOrdersSelection}
/>
{/* Étape 3 : confirmation finale */}
<Dialog open={replaceConfirmOpen} onClose={handleCancelReplace}>
<DialogTitle>Confirmer le remplacement du produit</DialogTitle>
<DialogContent>
<Typography>
Vous êtes sur le point de remplacer le produit <strong>{oldProductIdToReplace}</strong> dans{' '}
<strong>{ordersAffectedCount}</strong> commande(s) sélectionnée(s). Continuer ?
</Typography>
</DialogContent>
<DialogActions>
<Button onClick={handleCancelReplace} color="secondary">
Annuler
</Button>
<Button onClick={handleConfirmReplace} variant="contained" color="primary">
Confirmer
</Button>
</DialogActions>
</Dialog>
</Box>
);
}



# ** File: src/components/DistributeQuantityDialog.js **
// src/components/DistributeQuantityDialog.js
import React, { useState, useEffect } from 'react';
import {
Dialog,
DialogTitle,
DialogContent,
DialogActions,
Button,
Box,
TextField,
Typography,
} from '@mui/material';
import { updateDoc, doc, serverTimestamp } from 'firebase/firestore';
import { firestore } from '../firebase';
const DistributeQuantityDialog = ({ open, product, orders, onClose }) => {
// Create a state to hold updated quantities for each order (keyed by order id)
const [quantities, setQuantities] = useState({});
// When the dialog opens, initialize the quantities from the orders' items.
useEffect(() => {
if (open && product && orders) {
const initial = {};
orders.forEach((order) => {
const item = order.items.find((it) => it.id === product.id);
if (item) {
initial[order.id] = item.quantity;
}
});
setQuantities(initial);
}
}, [open, product, orders]);
// Handle quantity change for an order
const handleQuantityChange = (orderId, newQty) => {
setQuantities((prev) => ({
...prev,
[orderId]: newQty,
}));
};
// On confirm, update all orders with the new quantity for the product
const handleConfirm = async () => {
const batchUpdates = [];
for (const order of orders) {
const itemIndex = order.items.findIndex((it) => it.id === product.id);
if (itemIndex >= 0) {
const currentQty = order.items[itemIndex].quantity;
const newQty = parseInt(quantities[order.id], 10);
if (newQty !== currentQty) {
const updatedItems = [...order.items];
updatedItems[itemIndex] = { ...updatedItems[itemIndex], quantity: newQty };
batchUpdates.push(
updateDoc(doc(firestore, 'orders', order.id), {
items: updatedItems,
updatedAt: serverTimestamp(),
})
);
}
}
}
try {
await Promise.all(batchUpdates);
onClose();
} catch (error) {
console.error('Error updating distributed quantities:', error);
}
};
return (
<Dialog open={open} onClose={onClose} fullWidth maxWidth="sm">
<DialogTitle>Distribuer pour {product?.name}</DialogTitle>
<DialogContent dividers>
{orders && orders.length > 0 ? (
orders.map((order) => {
const item = order.items.find((it) => it.id === product.id);
if (!item) return null;
return (
<Box
key={order.id}
sx={{
display: 'grid',
gridTemplateColumns: '1fr 80px', // left = auto, right = fixed
alignItems: 'center',
gap: 2,
mb: 2,
}}
>
{/* Left side: 2 lines for order ID and email */}
<Box>
<Typography variant="body1">
Order {order.id}
</Typography>
<Typography variant="body2" color="text.secondary">
{order.email || 'N/A'}
</Typography>
</Box>
{/* Right side: the quantity field */}
<TextField
type="number"
size="small"
value={quantities[order.id] ?? item.quantity}
onChange={(e) => handleQuantityChange(order.id, e.target.value)}
inputProps={{ min: 0 }}
/>
</Box>
);
})
) : (
<Typography>Aucune commande trouvée pour ce produit.</Typography>
)}
</DialogContent>
<DialogActions>
<Button onClick={onClose} color="secondary">
Annuler
</Button>
<Button onClick={handleConfirm} variant="contained" color="primary">
Confirmer
</Button>
</DialogActions>
</Dialog>
);
};
export default DistributeQuantityDialog;



# ** File: src/components/CustomTbody.js **
// CustomTbody.js
import React from 'react';
const CustomTbody = React.forwardRef((props, ref) => (
<tbody ref={ref} {...props} />
));
export default CustomTbody;



# ** File: src/components/VirtualizedProductsTable.js **
// src/components/VirtualizedProductsTable.js
import React from 'react';
import { FixedSizeList as List } from 'react-window';
import AutoSizer from 'react-virtualized-auto-sizer';
import { usePricing } from '../contexts/PricingContext';    // <-- NEW
import { formatPrice } from '../utils/formatPrice';          // <-- NEW
// Define your columns
const columns = [
{ label: 'Bio', baseWidth: 40 },
{ label: 'Produit', baseWidth: 300 },
{ label: 'Catégorie', baseWidth: 150 },
{ label: 'Fournisseur', baseWidth: 120 },
{ label: 'Prix', baseWidth: 80 },
{ label: 'Quantité', baseWidth: 60 },
{ label: 'Ajouter', baseWidth: 60 },
];
const ROW_HEIGHT = 50;
/**
* RowRenderer: We pass getFinalPrice via itemData, so we can apply margin.
*/
function RowRendererWithoutHeader({ index, style, data }) {
const { products, addToBasket, scaledColumns, getFinalPrice } = data;
const product = products[index];
if (!product) return null;
// 1) Apply margin
const finalPrice = getFinalPrice(product.price);
// 2) Format it
const displayPrice = formatPrice(finalPrice);
return (
<div style={{ ...style, display: 'flex', borderBottom: '1px solid #eee' }}>
{/* Column 1: Bio */}
<div
style={{
width: scaledColumns[0].scaledWidth,
padding: '8px',
boxSizing: 'border-box',
}}
>
{product.bio ? '🌿' : ''}
</div>
{/* Column 2: Product Name */}
<div
style={{
width: scaledColumns[1].scaledWidth,
padding: '8px',
boxSizing: 'border-box',
}}
>
{product.name}
</div>
{/* Column 3: Category */}
<div
style={{
width: scaledColumns[2].scaledWidth,
padding: '8px',
boxSizing: 'border-box',
}}
>
{product.category}
</div>
{/* Column 4: Supplier */}
<div
style={{
width: scaledColumns[3].scaledWidth,
padding: '8px',
boxSizing: 'border-box',
}}
>
{product.supplier || ''}
</div>
{/* Column 5: Price (with margin) */}
<div
style={{
width: scaledColumns[4].scaledWidth,
padding: '8px',
boxSizing: 'border-box',
textAlign: 'right',
}}
>
${displayPrice}
</div>
{/* Column 6: Hard-coded "1" for quantity in your example */}
<div
style={{
width: scaledColumns[5].scaledWidth,
padding: '8px',
boxSizing: 'border-box',
}}
>
1
</div>
{/* Column 7: Add button */}
<div
style={{
width: scaledColumns[6].scaledWidth,
padding: '8px',
boxSizing: 'border-box',
}}
>
<button onClick={() => addToBasket(product, 1)}>Ajouter</button>
</div>
</div>
);
}
export default function VirtualizedProductsTable({ products, addToBasket }) {
// Pull getFinalPrice from context
const { getFinalPrice } = usePricing();
// The rest is your existing code for layout
const totalBaseWidth = columns.reduce((sum, col) => sum + col.baseWidth, 0);
return (
<div style={{ height: '80vh', width: '100%' }}>
<AutoSizer>
{({ width, height }) => {
const ratio = totalBaseWidth > 0 ? width / totalBaseWidth : 1;
const scaledColumns = columns.map((col) => ({
label: col.label,
scaledWidth: col.baseWidth * ratio,
}));
const headerHeight = ROW_HEIGHT;
const listHeight = height - headerHeight;
return (
<>
{/* Header row */}
<div
style={{
width: `${width}px`,
display: 'flex',
backgroundColor: '#F5F3EB',
fontWeight: 'bold',
height: headerHeight,
}}
>
{scaledColumns.map((col) => (
<div
key={col.label}
style={{
width: col.scaledWidth,
padding: '8px',
boxSizing: 'border-box',
borderRight: '1px solid #ddd',
}}
>
{col.label}
</div>
))}
</div>
{/* Scrolling list */}
<List
height={listHeight}
width={width}
itemCount={products.length}
itemSize={ROW_HEIGHT}
// We pass getFinalPrice in itemData so the row renderer can use it
itemData={{ products, addToBasket, scaledColumns, getFinalPrice }}
>
{RowRendererWithoutHeader}
</List>
</>
);
}}
</AutoSizer>
</div>
);
}



# ** File: src/components/OrderCard.js **
// src/components/OrderCard.js
import React, { useState, useEffect } from 'react';
import { collection, query, where, getDocs } from 'firebase/firestore';
import { firestore } from '../firebase';
import {
Paper,
Typography,
Box,
TextField,
Button
} from '@mui/material';
export default function OrderCard({
order,
onMarkDelivered,
onOpenSignaturePad,
onQuantityChange,
onAddProduct
}) {
const [address, setAddress] = useState(null);
const [companyName, setCompanyName] = useState('');
useEffect(() => {
const fetchPartnerInfo = async () => {
try {
const partnersRef = collection(firestore, 'res_partner');
const qPartners = query(partnersRef, where('email', '==', order.email));
const querySnapshot = await getDocs(qPartners);
if (!querySnapshot.empty) {
const partnerData = querySnapshot.docs[0].data();
setAddress(partnerData.contact_address_complete || '');
setCompanyName(partnerData.company_name || '');
}
} catch (error) {
console.error('Error fetching partner info', error);
}
};
fetchPartnerInfo();
}, [order.email]);
// 1) Compute total
const totalCost = (order.items || []).reduce(
(acc, item) => acc + item.price * item.quantity,
0
);
return (
<Paper sx={{ mb: 2, p: 2 }}>
<Typography variant="subtitle1" sx={{ fontWeight: 'bold' }}>
Order ID: {order.id}
</Typography>
{companyName && (
<Typography variant="body2" sx={{ mb: 1 }}>
Company: {companyName}
</Typography>
)}
<Typography variant="body2" sx={{ mb: 1 }}>
Email: {order.email}
</Typography>
{address && (
<Typography variant="body2" sx={{ mb: 1 }}>
Address: {address}
</Typography>
)}
<Typography variant="body2">
Delivery Status: {order.deliveryStatus || 'N/A'}
</Typography>
<Box sx={{ mt: 2 }}>
{(order.items || []).map((item) => (
<Box key={item.id} sx={{ mb: 1 }}>
<Box sx={{ display: 'flex', alignItems: 'center', gap: 2, flexWrap: 'wrap' }}>
{/* Item name */}
<Typography sx={{ flex: 1 }}>{item.name}</Typography>
{/* Supplier */}
<Typography sx={{ flex: 1 }}>
{item.supplier || 'N/A'}
</Typography>
{/* Price (not editable, just displayed) */}
<Typography sx={{ width: '80px', textAlign: 'right' }}>
${parseFloat(item.price).toFixed(2)}
</Typography>
{/* Quantity field: numeric-friendly for mobile */}
<TextField
type="number"
size="small"
value={item.quantity}
onChange={(e) => onQuantityChange(order.id, item.id, e.target.value)}
sx={{
width: { xs: '50px', sm: '60px' },
textAlign: 'right',
}}
inputProps={{
style: { textAlign: 'right' },
min: 0,
inputMode: 'numeric',
pattern: '[0-9]*'
}}
/>
</Box>
{/* Optional comment */}
{item.comment && (
<Typography variant="body2" sx={{ ml: 2, color: 'grey.600' }}>
Comment: {item.comment}
</Typography>
)}
</Box>
))}
</Box>
{/* 2) Show total cost at bottom */}
<Typography
variant="body2"
sx={{ textAlign: 'right', mt: 2, fontWeight: 'bold' }}
>
Total: ${totalCost.toFixed(2)}
</Typography>
<Box sx={{ mt: 2, display: 'flex', gap: 2, alignItems: 'center', flexWrap: 'wrap' }}>
<Button
variant="contained"
onClick={() => onMarkDelivered(order.id)}
disabled={!order.signature}
>
Mark Delivered
</Button>
<Button variant="contained" onClick={() => onAddProduct(order.id)}>
Ajouter un produit
</Button>
{/* If there's a signature, show it; otherwise show the capture button */}
{order.signature ? (
<Box
sx={{
border: '1px solid #ccc',
p: 1,
maxWidth: 200,
maxHeight: 100,
overflow: 'hidden'
}}
>
<img
src={order.signature}
alt="Signature"
style={{ width: '100%', height: 'auto' }}
/>
</Box>
) : (
<Button variant="outlined" onClick={() => onOpenSignaturePad(order.id)}>
Capture Signature
</Button>
)}
</Box>
</Paper>
);
}



# ** File: src/components/ProductEditDialog.js **
// src/components/ProductEditDialog.js
import React, { useState, useEffect } from 'react';
import {
Dialog,
DialogTitle,
DialogContent,
DialogActions,
TextField,
FormControlLabel,
Checkbox,
Button,
Box
} from '@mui/material';
export default function ProductEditDialog({ open, product, onClose, onSave }) {
const [editedProduct, setEditedProduct] = useState({});
useEffect(() => {
if (product) {
setEditedProduct(product);
}
}, [product]);
const handleChange = (field, value) => {
setEditedProduct(prev => ({
...prev,
[field]: value,
}));
};
const handleCheckboxChange = (field, event) => {
setEditedProduct(prev => ({
...prev,
[field]: event.target.checked,
}));
};
const handleSave = () => {
onSave(editedProduct);
};
return (
<Dialog open={open} onClose={onClose} fullWidth maxWidth="sm">
<DialogTitle>Modifier le produit</DialogTitle>
<DialogContent>
<Box component="form" sx={{ display: 'flex', flexDirection: 'column', gap: 2, mt: 1 }}>
<TextField
label="Nom"
variant="outlined"
fullWidth
value={editedProduct.name || ''}
onChange={(e) => handleChange('name', e.target.value)}
/>
<TextField
label="Code"
variant="outlined"
fullWidth
value={editedProduct.code || ''}
onChange={(e) => handleChange('code', e.target.value)}
/>
<TextField
label="Prix"
variant="outlined"
fullWidth
type="number"
value={editedProduct.price || ''}
onChange={(e) => handleChange('price', parseFloat(e.target.value))}
/>
<TextField
label="Catégorie"
variant="outlined"
fullWidth
value={editedProduct.category || ''}
onChange={(e) => handleChange('category', e.target.value)}
/>
<TextField
label="Fournisseur"
variant="outlined"
fullWidth
value={editedProduct.supplier || ''}
onChange={(e) => handleChange('supplier', e.target.value)}
/>
<FormControlLabel
control={
<Checkbox
checked={editedProduct.available || false}
onChange={(e) => handleCheckboxChange('available', e)}
/>
}
label="Disponible"
/>
{/* Add any additional product fields as needed */}
</Box>
</DialogContent>
<DialogActions>
<Button onClick={onClose} color="secondary">
Annuler
</Button>
<Button onClick={handleSave} variant="contained" color="primary">
Sauver
</Button>
</DialogActions>
</Dialog>
);
}



# ** File: src/components/Basket.js **
// src/components/Basket.js
import React, { useState, useEffect } from 'react';
import { Box, Button, Typography, IconButton, TextField, Collapse } from '@mui/material';
import RemoveCircleOutlineIcon from '@mui/icons-material/RemoveCircleOutline';
import ExpandLessIcon from '@mui/icons-material/ExpandLess';
import ExpandMoreIcon from '@mui/icons-material/ExpandMore';
import { usePricing } from '../contexts/PricingContext';
import { formatPrice } from '../utils/formatPrice';
function Basket({ basket, updateBasketItem, updateBasketItemComment, removeBasketItem, saveOrder, isOrderAllowed }) {
const [expanded, setExpanded] = useState(false);
const [commentOpen, setCommentOpen] = useState({});
const { getFinalPrice } = usePricing();
useEffect(() => {
setCommentOpen(prev => {
const newState = { ...prev };
basket.forEach(item => {
if (item.comment && item.comment.trim() !== '' && !newState[item.id]) {
newState[item.id] = true;
}
});
return newState;
});
}, [basket]);
const toggleExpand = () => setExpanded(!expanded);
const toggleComment = (id) => {
setCommentOpen(prev => ({ ...prev, [id]: !prev[id] }));
};
// Compute total cost using the final (margin-adjusted) price
const totalCostValue = basket.reduce((acc, item) => {
const finalPrice = getFinalPrice(item.price);
return acc + finalPrice * item.quantity;
}, 0);
const totalCost = totalCostValue.toFixed(2);
return (
<Box
sx={{
position: 'fixed',
bottom: 0,
left: 0,
right: 0,
backgroundColor: 'background.paper',
borderTop: '1px solid',
borderColor: 'grey.300',
p: 2,
boxShadow: 3,
}}
>
<Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>
<Button onClick={toggleExpand} endIcon={expanded ? <ExpandLessIcon /> : <ExpandMoreIcon />}>
{expanded ? 'Masquer le panier' : 'Afficher le panier'}
</Button>
<Typography variant="body1">
{basket.length} articles | Total : ${totalCost}
</Typography>
</Box>
<Collapse in={expanded}>
<Box sx={{ maxHeight: '50vh', overflowY: 'auto', mt: 2 }}>
{basket.length === 0 ? (
<Typography>Aucun article dans le panier</Typography>
) : (
<>
{[...basket]
.sort((a, b) => a.name.localeCompare(b.name))
.map((item) => {
const finalPrice = getFinalPrice(item.price);
const formattedPrice = formatPrice(finalPrice);
const lineTotal = (finalPrice * item.quantity).toFixed(2);
return (
<Box key={item.id} sx={{ display: 'flex', flexDirection: 'column', mb: 1, gap: 1 }}>
<Box
sx={{
display: 'flex',
alignItems: 'center',
gap: 2,
flexWrap: 'wrap',
}}
>
<Typography sx={{ flex: 2 }}>
{item.name} - ${formattedPrice}
</Typography>
<Typography sx={{ width: '100px', textAlign: 'right' }}>
${lineTotal}
</Typography>
<TextField
type="number"
value={item.quantity}
onChange={(e) => updateBasketItem(item.id, parseInt(e.target.value, 10))}
inputProps={{ min: 1 }}
size="small"
sx={{ width: '60px' }}
/>
<IconButton onClick={() => removeBasketItem(item.id)}>
<RemoveCircleOutlineIcon />
</IconButton>
<Button variant="text" onClick={() => toggleComment(item.id)}>
{commentOpen[item.id] ? 'Masquer le commentaire' : 'Ajouter un commentaire'}
</Button>
</Box>
{commentOpen[item.id] && (
<TextField
label="Commentaire"
variant="outlined"
fullWidth
value={item.comment || ''}
onChange={(e) => updateBasketItemComment(item.id, e.target.value)}
/>
)}
</Box>
);
})}
</>
)}
</Box>
{basket.length > 0 && totalCostValue < 400 && (
<Typography
variant="caption"
color="error"
sx={{ mt: 1, display: 'block', fontSize: '1rem' }}
>
On n’est pas encore à 400$, c'est le minimum pour la livraison.
</Typography>
)}
{basket.length > 0 && (
<>
{!isOrderAllowed && (
<Typography variant="caption" color="error" sx={{ display: 'block', mt: 1 }}>
Les commandes ne peuvent être passées que du lundi au mercredi.
</Typography>
)}
</>
)}
</Collapse>
</Box>
);
}
export default Basket;



# ** File: src/components/ProductsPage.js **
// src/components/ProductsPage.js
import React, { useState, useEffect, useRef } from 'react';
import {
collection,
onSnapshot,
addDoc,
updateDoc,
doc,
getDocs,
query,
where,
serverTimestamp,
} from 'firebase/firestore';
import { firestore } from '../firebase';
import { Link } from 'react-router-dom';
import {
Container,
Typography,
Button,
Box
} from '@mui/material';
import Logo from '../logo.svg';
import { signOut } from 'firebase/auth';
import { auth } from '../firebase';
// Import our FilterBar and ResponsiveProductsView:
import FilterBar from './FilterBar';
import ResponsiveProductsView from './ResponsiveProductsView';
import Basket from './Basket';
import { getWeekCode } from '../utils/dateUtils';
function ProductsPage({ user, isDelivery }) {
// --- State for products, basket, user address, etc.
const [products, setProducts] = useState([]);
const [basket, setBasket] = useState([]);
const [userAddress, setUserAddress] = useState('');
const [activeOrderId, setActiveOrderId] = useState(null);
// --- Filter states
const [searchTerm, setSearchTerm] = useState('');
const [selectedCategory, setSelectedCategory] = useState('');
const [selectedSupplier, setSelectedSupplier] = useState('');
const [bioOnly, setBioOnly] = useState(false);
// For auto-saving
const lastRemoteBasketRef = useRef([]);
// For restricting orders to certain days
const today = new Date();
const allowedDays = [1, 2, 3]; // Monday=1, Tuesday=2, Wednesday=3
// or set by environment
const bypassOrderRestrictions = process.env.REACT_APP_BYPASS_ORDER_RESTRICTION === 'true';
const isOrderAllowed = bypassOrderRestrictions || allowedDays.includes(today.getDay());
// Current week code
const currentWeek = getWeekCode(today);
// ------------------------------------------------------------------
//  1) Retrieve user's address from "res_partner"
// ------------------------------------------------------------------
useEffect(() => {
if (user && user.email) {
const fetchAddress = async () => {
try {
const partnersRef = collection(firestore, 'res_partner');
const qPartner = query(partnersRef, where('email', '==', user.email));
const querySnapshot = await getDocs(qPartner);
if (!querySnapshot.empty) {
const partnerData = querySnapshot.docs[0].data();
setUserAddress(partnerData.contact_address_complete || '');
}
} catch (error) {
console.error("Error retrieving address from res_partner:", error);
}
};
fetchAddress();
}
}, [user]);
// ------------------------------------------------------------------
//  2) Retrieve all products (available == true)
// ------------------------------------------------------------------
useEffect(() => {
const productsRef = collection(firestore, 'products');
const q = query(productsRef, where('available', '==', true));
const unsubscribe = onSnapshot(q, (snapshot) => {
const prods = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
setProducts(prods);
});
return () => unsubscribe();
}, []);
// ------------------------------------------------------------------
//  3) Load an "open" order for the user (status == 'open')
// ------------------------------------------------------------------
useEffect(() => {
const ordersRef = collection(firestore, 'orders');
const qOrders = query(
ordersRef,
where('userId', '==', user.uid),
where('status', '==', 'open')
);
const unsubscribe = onSnapshot(qOrders, (snapshot) => {
if (!snapshot.empty) {
// pick the most recently updated open order
const openOrders = snapshot.docs.sort((a, b) => {
const aTime = a.data().updatedAt ? a.data().updatedAt.seconds : 0;
const bTime = b.data().updatedAt ? b.data().updatedAt.seconds : 0;
return bTime - aTime;
});
const activeOrder = openOrders[0];
const data = activeOrder.data();
setActiveOrderId(activeOrder.id);
const remoteItems = data.items || [];
// If remote items differ from local basket, sync them
if (JSON.stringify(remoteItems) !== JSON.stringify(basket)) {
setBasket(remoteItems);
}
lastRemoteBasketRef.current = remoteItems;
} else {
// no open orders, so no basket
setActiveOrderId(null);
setBasket([]);
lastRemoteBasketRef.current = [];
}
});
return () => unsubscribe();
}, [user.uid]);
// ------------------------------------------------------------------
//  Basket modifications
// ------------------------------------------------------------------
const addToBasket = (product, quantity) => {
setBasket(prev => {
const existing = prev.find(item => item.id === product.id);
if (existing) {
return prev.map(item =>
item.id === product.id
? { ...item, quantity: item.quantity + quantity }
: item
);
} else {
return [...prev, { ...product, quantity }];
}
});
};
const updateBasketItem = (id, newQuantity) => {
setBasket(prev =>
prev.map(item => (item.id === id ? { ...item, quantity: newQuantity } : item))
);
};
const updateBasketItemComment = (id, comment) => {
setBasket(prev =>
prev.map(item => (item.id === id ? { ...item, comment } : item))
);
};
const removeBasketItem = (id) => {
setBasket(prev => prev.filter(item => item.id !== id));
};
// ------------------------------------------------------------------
//  Manual order saving
// ------------------------------------------------------------------
const saveOrder = async () => {
if (basket.length === 0) {
alert("Le panier est vide !");
return;
}
if (!isOrderAllowed) {
alert("Les commandes ne peuvent être passées que du lundi au mercredi.");
return;
}
const orderData = {
userId: user.uid,
email: user.email,
items: basket,
weekCode: getWeekCode(new Date()),
status: "open",
updatedAt: serverTimestamp(),
createdAt: serverTimestamp(),
};
try {
if (activeOrderId) {
await updateDoc(doc(firestore, 'orders', activeOrderId), orderData);
alert('Commande mise à jour !');
} else {
const docRef = await addDoc(collection(firestore, 'orders'), orderData);
setActiveOrderId(docRef.id);
alert('Commande créée et enregistrée !');
}
} catch (error) {
console.error('Error saving order:', error);
alert('Erreur lors de l\'enregistrement de la commande');
}
};
// ------------------------------------------------------------------
//  Auto-save effect
// ------------------------------------------------------------------
useEffect(() => {
const timeoutId = setTimeout(() => {
if (!activeOrderId && basket.length > 0) {
// Create new order when there is no active order and basket is non-empty
const orderData = {
userId: user.uid,
email: user.email,
items: basket,
weekCode: getWeekCode(new Date()),
status: "open",
updatedAt: serverTimestamp(),
createdAt: serverTimestamp(),
};
addDoc(collection(firestore, 'orders'), orderData)
.then(docRef => {
setActiveOrderId(docRef.id);
lastRemoteBasketRef.current = basket;
})
.catch(error => {
console.error('Error auto-creating order', error);
});
} else if (activeOrderId) {
// If we do have an active order, only update if basket changed
if (JSON.stringify(basket) !== JSON.stringify(lastRemoteBasketRef.current)) {
updateDoc(doc(firestore, 'orders', activeOrderId), {
items: basket,
updatedAt: serverTimestamp(),
})
.then(() => {
lastRemoteBasketRef.current = basket;
})
.catch(error => {
console.error(`Error updating order ${activeOrderId}`, error);
});
}
}
}, 500);
return () => clearTimeout(timeoutId);
}, [basket, activeOrderId, user.uid]);
// ------------------------------------------------------------------
//  Filter logic
// ------------------------------------------------------------------
const distinctCategories = Array.from(new Set(products.map(p => p.category))).sort();
const distinctSuppliers = Array.from(new Set(products.map(p => p.supplier))).sort();
// Filter products based on the states
const filteredProducts = products.filter(product => {
const matchesSearch = product.name
.toLowerCase()
.includes(searchTerm.toLowerCase());
const matchesCategory = selectedCategory
? product.category === selectedCategory
: true;
const matchesSupplier = selectedSupplier
? product.supplier === selectedSupplier
: true;
const matchesBio = bioOnly ? product.bio === true : true;
return matchesSearch && matchesCategory && matchesSupplier && matchesBio;
});
// ------------------------------------------------------------------
//  CUSTOM SORT: FRUITS -> LEGUMES -> everything else
// ------------------------------------------------------------------
const categoryPriority = {
FRUITS: 1,
LEGUMES: 2,
};
const sortedFilteredProducts = [...filteredProducts].sort((a, b) => {
const catA = (a.category || '').toUpperCase();
const catB = (b.category || '').toUpperCase();
const priorityA = categoryPriority[catA] || 999;  // 999 if not FRUITS or LEGUMES
const priorityB = categoryPriority[catB] || 999;
// First compare priority
if (priorityA !== priorityB) {
return priorityA - priorityB;
}
// If same priority, compare category alphabetically
const catComparison = catA.localeCompare(catB);
if (catComparison !== 0) {
return catComparison;
}
// If same category, compare name alphabetically
return (a.name || '').localeCompare(b.name || '');
});
// ------------------------------------------------------------------
//  Logout handler
// ------------------------------------------------------------------
const handleLogout = async () => {
try {
await signOut(auth);
} catch (error) {
console.error("Error signing out:", error);
}
};
// ------------------------------------------------------------------
//  Render
// ------------------------------------------------------------------
return (
<Container sx={{ pt: 4, pb: 10 }}>
{/* Header / Logo / Buttons */}
<Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'flex-start', mb: 2 }}>
<Box>
<img src={Logo} alt="Logo" style={{ height: '40px', marginBottom: '10px' }} />
<br />
<Button variant="outlined" component={Link} to="/orders" sx={{ mt: 1 }}>
Voir l'historique des commandes
</Button>
</Box>
<Box sx={{ textAlign: 'right' }}>
{user && (
<>
<Typography variant="body1" sx={{ fontWeight: 'bold' }}>
{user.email}
</Typography>
<Button
variant="outlined"
color="secondary"
onClick={handleLogout}
sx={{ mt: 1 }}
>
Déconnexion
</Button>
{isDelivery && (
<Button variant="outlined" component={Link} to="/delivery" sx={{ mt: 1, ml: 1 }}>
Tableau de bord des livraisons
</Button>
)}
{userAddress && (
<Typography variant="body2" sx={{ color: 'text.secondary' }}>
{userAddress}
</Typography>
)}
<Typography variant="body2" sx={{ color: 'text.secondary', mt: 1 }}>
Semaine: {currentWeek}
</Typography>
</>
)}
</Box>
</Box>
{/* Filter Bar (with mobile dialog) */}
<FilterBar
searchTerm={searchTerm}
setSearchTerm={setSearchTerm}
selectedCategory={selectedCategory}
setSelectedCategory={setSelectedCategory}
selectedSupplier={selectedSupplier}
setSelectedSupplier={setSelectedSupplier}
bioOnly={bioOnly}
setBioOnly={setBioOnly}
distinctCategories={distinctCategories}
distinctSuppliers={distinctSuppliers}
/>
{/* Product list/table (responsive) */}
<Box className="table-container">
<ResponsiveProductsView
products={sortedFilteredProducts}
addToBasket={addToBasket}
/>
</Box>
{/* Basket (at bottom) */}
<Basket
basket={basket}
updateBasketItem={updateBasketItem}
updateBasketItemComment={updateBasketItemComment}
removeBasketItem={removeBasketItem}
saveOrder={saveOrder}
isOrderAllowed={isOrderAllowed}
/>
</Container>
);
}
export default ProductsPage;



# ** File: src/components/ProductsManager.js **
// src/components/ProductsManager.js
import React, { useState, useEffect } from 'react';
import { collection, query, onSnapshot, updateDoc, doc } from 'firebase/firestore';
import { firestore } from '../firebase';
import { Container, Typography, Box, List, ListItem, ListItemText, Divider, Button } from '@mui/material';
import FilterBar from './FilterBar';
import ProductEditDialog from './ProductEditDialog';
import AddProductDialog from './AddProductDialog';
export default function ProductsManager({ user }) {
const [products, setProducts] = useState([]);
const [searchTerm, setSearchTerm] = useState('');
const [selectedCategory, setSelectedCategory] = useState('');
const [selectedSupplier, setSelectedSupplier] = useState('');
const [bioOnly, setBioOnly] = useState(false);
const [selectedProduct, setSelectedProduct] = useState(null);
const [refreshToggle, setRefreshToggle] = useState(false);
const [addDialogOpen, setAddDialogOpen] = useState(false);
// Fetch all products (admins see everything)
useEffect(() => {
const productsRef = collection(firestore, 'products');
const q = query(productsRef);
const unsubscribe = onSnapshot(q, (snapshot) => {
const prods = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
setProducts(prods);
});
return () => unsubscribe();
}, [refreshToggle]);
// Prepare filter options
const distinctCategories = Array.from(new Set(products.map(p => p.category))).sort();
const distinctSuppliers = Array.from(new Set(products.map(p => p.supplier))).sort();
const filteredProducts = products.filter(product => {
const matchesSearch = product.name.toLowerCase().includes(searchTerm.toLowerCase());
const matchesCategory = selectedCategory ? product.category === selectedCategory : true;
const matchesSupplier = selectedSupplier ? product.supplier === selectedSupplier : true;
const matchesBio = bioOnly ? product.bio === true : true;
return matchesSearch && matchesCategory && matchesSupplier && matchesBio;
});
const handleProductClick = (product) => {
setSelectedProduct(product);
};
const handleDialogClose = () => {
setSelectedProduct(null);
};
const handleProductSave = async (updatedProduct) => {
try {
await updateDoc(doc(firestore, 'products', updatedProduct.id), updatedProduct);
setRefreshToggle(!refreshToggle);
setSelectedProduct(null);
} catch (error) {
console.error("Error updating product:", error);
}
};
const handleAddProduct = (product) => {
// When a new product is added, refresh list and close the dialog
setRefreshToggle(!refreshToggle);
setAddDialogOpen(false);
};
return (
<Container sx={{ pt: 4, pb: 4 }}>
<Typography variant="h4" gutterBottom>
Gestionnaire de produits
</Typography>
{/* Add New Product button */}
<Box sx={{ mb: 2 }}>
<Button variant="contained" color="primary" onClick={() => setAddDialogOpen(true)}>
Ajouter un nouveau produit
</Button>
</Box>
<FilterBar
searchTerm={searchTerm}
setSearchTerm={setSearchTerm}
selectedCategory={selectedCategory}
setSelectedCategory={setSelectedCategory}
selectedSupplier={selectedSupplier}
setSelectedSupplier={setSelectedSupplier}
bioOnly={bioOnly}
setBioOnly={setBioOnly}
distinctCategories={distinctCategories}
distinctSuppliers={distinctSuppliers}
/>
<Box sx={{ mt: 2 }}>
{filteredProducts.length === 0 ? (
<Typography>Aucun produit trouvé.</Typography>
) : (
<List>
{filteredProducts.map(product => (
<React.Fragment key={product.id}>
<ListItem button onClick={() => handleProductClick(product)}>
<ListItemText
primary={product.name}
secondary={`Code: ${product.code || '-'} | Prix: $${parseFloat(product.price).toFixed(2)} | Disponible: ${product.available ? 'Oui' : 'Non'}`}
/>
</ListItem>
<Divider />
</React.Fragment>
))}
</List>
)}
</Box>
{selectedProduct && (
<ProductEditDialog
open={Boolean(selectedProduct)}
product={selectedProduct}
onClose={handleDialogClose}
onSave={handleProductSave}
/>
)}
{/* Dialog for adding a new product */}
{addDialogOpen && (
<AddProductDialog
open={addDialogOpen}
onClose={() => setAddDialogOpen(false)}
onProductSelect={handleAddProduct}
defaultMode="manual"
/>
)}
</Container>
);
}



# ** File: src/hooks/useDeliveryAggregation.js **
// src/hooks/useDeliveryAggregation.js
import { useEffect, useState } from 'react';
import { collection, query, where, onSnapshot, doc, getDoc } from 'firebase/firestore';
import { firestore } from '../firebase';
import { getWeekCode } from '../utils/dateUtils';
export function useDeliveryAggregation() {
const [orders, setOrders] = useState([]);
const [aggregatedBySupplier, setAggregatedBySupplier] = useState({});
const [supplierInvoiceUrl, setSupplierInvoiceUrl] = useState({});
const currentWeek = getWeekCode(new Date());
// 1) Fetch orders for current week
useEffect(() => {
const wc = getWeekCode(new Date());
const ordersRef = collection(firestore, 'orders');
const qOrders = query(ordersRef, where('weekCode', '==', wc));
const unsub = onSnapshot(qOrders, (snapshot) => {
const data = snapshot.docs.map(d => ({ id: d.id, ...d.data() }));
setOrders(data);
});
return () => unsub();
}, []);
// 2) Recompute aggregatedBySupplier whenever orders changes
useEffect(() => {
const newAggregated = {};
orders.forEach(order => {
// Suppose we store a "companyName" in the order doc
// or we fall back to the order's email:
const company = order.companyName || order.email || "Unknown";
if (order.items) {
order.items.forEach(item => {
const supplier = item.supplier || 'Unknown';
// Initialize that supplier if missing
if (!newAggregated[supplier]) {
newAggregated[supplier] = {};
}
// If this product doesn't exist yet in the aggregator, create it
if (!newAggregated[supplier][item.id]) {
newAggregated[supplier][item.id] = {
...item,
comments: []  // store array of {company, comment}
};
} else {
// If it already exists, just increment quantity
newAggregated[supplier][item.id].quantity += item.quantity;
}
// If there's a comment, push {company, comment} object
if (item.comment && item.comment.trim() !== "") {
newAggregated[supplier][item.id].comments.push({
company,
comment: item.comment
});
}
});
}
});
setAggregatedBySupplier(newAggregated);
}, [orders]);
// 3) (Optional) Check for uploaded invoices
async function reloadInvoices(aggregatedObj) {
for (const supplier of Object.keys(aggregatedObj)) {
const docId = `${currentWeek}_${supplier}`;
const invoiceDocRef = doc(firestore, 'delivery_invoices', docId);
const snapshot = await getDoc(invoiceDocRef);
if (snapshot.exists()) {
const data = snapshot.data();
if (data.invoiceUrl) {
setSupplierInvoiceUrl((prev) => ({
...prev,
[supplier]: data.invoiceUrl
}));
}
}
}
}
useEffect(() => {
reloadInvoices(aggregatedBySupplier);
// eslint-disable-next-line react-hooks/exhaustive-deps
}, [aggregatedBySupplier]);
return {
orders,
aggregatedBySupplier,
supplierInvoiceUrl,
reloadInvoices,
currentWeek,
};
}



# ** File: src/hooks/useMargin.js **
import { useState, useEffect } from 'react';
import { doc, onSnapshot } from 'firebase/firestore';
import { firestore } from '../firebase';
/**
* Custom hook to fetch the margin percentage from Firestore.
* It listens to the document at settings/sales and returns the margin,
* defaulting to 0 if not set.
*/
export function useMargin() {
const [margin, setMargin] = useState(0);
useEffect(() => {
const marginDocRef = doc(firestore, 'settings', 'sales');
const unsubscribe = onSnapshot(marginDocRef, (snapshot) => {
if (snapshot.exists()) {
const data = snapshot.data();
setMargin(data.margin ?? 0);
} else {
setMargin(0);
}
});
return () => unsubscribe();
}, []);
return margin;
}

